# External GPT5-Pro Audit Snapshot
Generated at 2025-10-16T05:13:54.403203+00:00

## Repository Layout
./
  .codex_ci/
  .git/ (contents omitted)
  .selftest_workspace/ (gitignored; contents omitted)
  .venv/ (gitignored; contents omitted)
  bin/
    bin/fake-codex
    bin/rex-codex
  documents/
    documents/feature_cards/
    documents/design_review.md
  for_external_GPT5_pro_audit/
    for_external_GPT5_pro_audit/audit_20251015212707.md
    for_external_GPT5_pro_audit/audit_20251015214523.md
    for_external_GPT5_pro_audit/audit_20251015220825.md
    for_external_GPT5_pro_audit/audit_20251016045436.md
    for_external_GPT5_pro_audit/audit_20251016051354.md
  lib/
    lib/burn.sh
    lib/discriminator.sh
    lib/generator.sh
    lib/init.sh
    lib/loop.sh
    lib/supervisor.sh
    lib/updater.sh
    lib/util.sh
  rex_codex/
    rex_codex/__init__.py
    rex_codex/__main__.py
    rex_codex/burn.py
    rex_codex/cards.py
    rex_codex/cli.py
    rex_codex/config.py
    rex_codex/discriminator.py
    rex_codex/doctor.py
    rex_codex/generator.py
    rex_codex/hermetic.py
    rex_codex/init.py
    rex_codex/install.py
    rex_codex/logs.py
    rex_codex/loop.py
    rex_codex/self_update.py
    rex_codex/status.py
    rex_codex/uninstall.py
    rex_codex/utils.py
  scripts/
    scripts/install.sh
    scripts/selftest_loop.sh
    scripts/smoke_e2e.sh
  templates/
    templates/documents/
      templates/documents/feature_cards/ (depth limit)
    templates/tests/
      templates/tests/enforcement/ (depth limit)
    templates/.flake8
    templates/AGENTS.md
    templates/conftest.py
    templates/mypy.ini
    templates/pyproject.toml
    templates/pytest.ini
    templates/requirements-dev.txt
  tests/
    tests/test_cards.py
    tests/test_cli_install.py
    tests/test_generator_guard.py
  .codex_ci_latest.log
  .gitignore
  AGENTS.md
  README.md
  VERSION

## File Snapshots

=== /media/skynet3/8tb_a1/rex_codex_agent/AGENTS.md ===
# rex_codex_agent · Operations Guide

This repository ships the **Codex-first automation scaffold** that installs via `./rex-codex`. It is deliberately opinionated:

- **Platform:** Linux shells (Bash 4+) or WSL.
- **Language/tooling:** Python projects (pytest, mypy, ruff, black, isort, flake8) with coverage ≥80% by default.
- **LLM:** OpenAI Codex invoked through `npx @openai/codex` (Node 18+). Discriminator LLM edits are opt-in (`DISABLE_LLM=1` by default).
- **Audit goals:**
  1. Maintain a folder named `for_external_GPT5_pro_audit/` in each working repository.
  2. After every interaction, commit and push the current state of the repository and drop into that folder a concatenated snapshot of every important script/markdown/readme file, each prefixed with its absolute path.
- **Self-development loop:** `bin/fake-codex`, `scripts/selftest_loop.sh`, and `scripts/smoke_e2e.sh` must stay executable and green. We dogfood the agent by reinstalling it into clean workspaces and running the generator → discriminator pipeline offline.

The Bash wrapper is now a shim; all orchestration lives in the Python package `rex_codex` so we can unit-test and extend behaviour without shell metaprogramming.

Keep these expectations visible—both docs and templates must reinforce them so future LLM audits stay aligned.

---

## Golden Path (from empty repo to green)

1. **Install wrapper (inside the target repo)**
   ```bash
   curl -fsSL https://raw.githubusercontent.com/rexdouglass/rex_codex_agent/main/scripts/install.sh | bash
   ```
2. **Bootstrap guardrails and tooling**
   ```bash
   ./rex-codex init
   ./rex-codex doctor      # verify python/node/docker availability
   ```
3. **Author a Feature Card**
   - Use `./rex-codex card new` for a guided prompt (writes `documents/feature_cards/<slug>.md` with `status: proposed`).
   - If you hand-edit, keep the `status:` line intact and leave `## Links` / `## Spec Trace` empty—the generator appends to them.
4. **Generate deterministic specs**
   ```bash
   ./rex-codex generator            # loops with a critic until DONE (use --single-pass to exit early)
   ```
   The generator:
   - Keeps diffs under `tests/feature_specs/<slug>/…` (tests only) and appends links/trace in the card.
   - Prints a dashboard summarising the Feature Card (acceptance criteria, existing specs) and previews the diff with new/updated tests before applying patches so operators can follow along in one screen.
   - Enforces patch-size limits (default 6 files / 300 lines).
   - Warns when cards exist but their `status:` values don't match the requested set (e.g. typos like `propsed`) so operators can repair metadata quickly.
   - Runs an AST hermeticity scan that bans network, subprocess, clock, and entropy **calls** (`requests.get`, `subprocess.run`, `time.sleep`, `uuid.uuid4`, `os.urandom`, `secrets`, `numpy.random`…), plus unconditional skip/xfail.
5. **Run the discriminator ladder**
   ```bash
   ./rex-codex discriminator --feature-only   # smoke/unit on the spec shard (pytest -x --maxfail=1)
   ./rex-codex discriminator --global         # full ladder (xdist auto, coverage ≥80%)
   ```
   Stages = health → tooling → smoke/unit → coverage → optional `pip-audit`/`bandit`/`build` → style/type (`black`, `isort`, `ruff`, `flake8`, `mypy`). Each pass now ends with a color summary (stage, result, duration, first failing line) plus a “next command” hint if anything failed. Logs + JUnit land in `.codex_ci/`. Successful passes are recorded in `rex-agent.json`.
6. **Iterate via the loop**
   ```bash
  ./rex-codex loop                # generator → feature → global
  ./rex-codex loop --explain      # preview planned stages before execution
  ./rex-codex loop --discriminator-only   # implement runtime without re-triggering generator
  DISABLE_LLM=0 ./rex-codex loop --discriminator-only   # or add --enable-llm to discriminator/loop for guarded runtime edits
  ```
   The loop finishes with a two-line scoreboard (generator vs discriminator) so operators immediately know which phase passed, warned, or failed.
   Every invocation also generates `for_external_GPT5_pro_audit/audit_<timestamp>.md`, stages all changes, and pushes the repository so external GPT5-Pro audits can start from the latest state.
7. **Promote the Feature Card**
   - When the repo is green, edit the card to `status: accepted` (generator never changes statuses). Commit your changes.

> Reset sandbox? `./rex-codex burn --dry-run` → `./rex-codex burn -y` → `./rex-codex init`.

### Self-development loop (maintainers run this constantly)

- `bin/fake-codex` emulates Codex and emits deterministic, hermetic diffs under `tests/feature_specs/<slug>/`. Keep it executable and versioned with the agent.
- `scripts/selftest_loop.sh` resets `.selftest_workspace/`, installs the current checkout, runs two Feature Cards (`hello_greet`, `hello_cli`) through generator → discriminator, appends logs/status/spec listings/runtime code to the latest audit file, then removes the workspace (`SELFTEST_KEEP=1` preserves it for debugging).
- `scripts/smoke_e2e.sh` spins up a temp repo, installs the current checkout via `scripts/install.sh`, scaffolds the `hello_greet` and `hello_cli` Feature Cards, runs `./rex-codex loop --feature-only`, then executes the global discriminator sweep. Export `KEEP=1` while debugging to retain the workspace.
- Run the selftest loop before accepting PRs, bumping `VERSION`, or cutting releases; use the broader smoke harness to cross-check longer flows. Treat failures as blockers—they signal the agent can no longer bootstrap itself offline.
- After both loops pass, repeat the Golden Path manually in a new repo (your target project—e.g. the practice Pong game) to confirm end-to-end behaviour beyond the stub.

---

## Guardrails & Defaults

- **Tests-first:** generator only writes specs; runtime changes must be manual or pass the discriminator’s guarded LLM step.
- **Protected surfaces:** tests, Feature Cards, documents, CI configs, dependency manifests, tooling configs are hash-snapshotted before LLM edits—unauthorized changes are reverted.
- **Runtime allow-list:** discriminator LLM patches may only touch runtime directories (`src/`, detected packages). Non-runtime paths are rejected.
- **Patch-size budgets:** generator and discriminator enforce defaults of 6 files / 300 lines (override via `GENERATOR_MAX_FILES/LINES`, `DISCRIMINATOR_MAX_FILES/LINES`).
- **Determinism:** hermetic specs ban network/entropy/time/subprocess calls; `PYTHONHASHSEED=0` is exported for generator snapshots and discriminator runs; pytest stages use configurable timeouts.
- **Coverage-first:** `COVERAGE_MIN` defaults to 80%; targets default to `src/`. Optional gates activate with `PIP_AUDIT=1`, `BANDIT=1`, `PACKAGE_CHECK=1`.
- **Auto-style:** mechanical `ruff/black/isort` runs only on runtime targets (never tests/docs).
- **Mypy scope:** type checking defaults to runtime targets (`MYPY_TARGETS` or `COVERAGE_TARGETS`); set `MYPY_INCLUDE_TESTS=1` to include spec shards when required.
- **Concurrency:** generator, discriminator, and loop take `.codex_ci/*.lock` with Python advisory (`fcntl`) locks.
- **Telemetry:** `rex-agent.json` tracks active slug/card and discriminator success metadata for auditability.

---

## Command Reference (internal expectations)

| Command | Notes for maintainers |
|---------|----------------------|
| `init` | Must remain idempotent. Seeds templates, enforces deterministic tool versions (see `templates/requirements-dev.txt`). |
| `generator` | Keep prompt guardrails aligned with code filters. Never relax hermetic checks without updating docs/templates. |
| `discriminator` | Maintain stage banners, logging, and optional gate envs. Default LLM usage must stay disabled (`DISABLE_LLM=1`). |
| `loop` | Orchestrates generator → discriminator. Ensure flag passthrough stays consistent with docs. |
| `card` | CLI helper for card creation/listing/validation—keep prompts aligned with template README. |
| `status` / `logs` | Surface rex-agent.json metadata and `.codex_ci` tails; `logs` supports `--generator/--discriminator/--lines`. |
| `doctor` | Emit versions/paths for python/node/docker; add tooling here before relying on it elsewhere. |
| `burn` | Preserve `.git`, warn loudly, honour `--dry-run` / `--purge-agent`. |
| `uninstall` | `--force` skips the prompt; `--keep-wrapper` leaves the shim in place. |
| `self-update` | Default is **offline** (`REX_AGENT_NO_UPDATE=1`). Respect release tags (`VERSION`) when enabling `stable`. |

---

## Quick Command Cheatsheet

- `./rex-codex init` – seed guardrails and tooling (idempotent).
- `./rex-codex card new` – scaffold a Feature Card; `card list` / `card validate` keep hygiene tight.
- `./rex-codex install --force` – refresh the agent sources in-place and automatically rerun `init`/`doctor` (use `--skip-init` / `--skip-doctor` to opt out).
- `curl -fsSL https://raw.githubusercontent.com/rexdouglass/rex_codex_agent/main/scripts/install.sh | bash -s -- --force --channel main` – reinstall the latest agent snapshot from anywhere.
- `./rex-codex generator --tail 120` – replay Codex diffs and tail logs when the generator fails (add `--quiet` to silence).
- `./rex-codex discriminator --feature-only` / `--global` – run the shard or full ladder; add `--tail 120` (and `--quiet` if you want silence) during debug sessions.
- `./rex-codex loop --tail 120` – generator → feature shard → global sweep with inline diff previews (use `--quiet` to suppress diff chatter).
- `./rex-codex logs --generator --lines 200` – dump the latest generator response/patch without hunting for files.
- `GENERATOR_PROGRESS_SECONDS=5 ./rex-codex loop` – tighten the Codex heartbeat interval (default 15s) for long generator passes.
- `./rex-codex status` – inspect the active slug/card and last discriminator success metadata.
- `./rex-codex burn --yes` – reset the working tree (keeps `.git`; add `--purge-agent` to drop `.rex_agent`).
- `./rex-codex uninstall --force` – remove the agent (use `--keep-wrapper` to leave the shim).
- `scripts/selftest_loop.sh` – fast offline selftest that resets `.selftest_workspace/`, exercises the `hello_greet` and `hello_cli` Feature Cards, and appends logs/status/spec listings to the latest audit file (`SELFTEST_KEEP=1` preserves the workspace).
- `scripts/smoke_e2e.sh` – run the self-development loop offline; export `KEEP=1` to keep the temp repo when investigating failures.

## Documentation Duties

- Update this file, `README.md`, and templates in `templates/` whenever behaviour, defaults, or guardrails change.
- Keep the docs explicit that the agent is Python/Linux/Codex-specific—LLMs reviewing the repo should never infer cross-language support.

---

## Release Conventions

- Bump `VERSION` and tag (`vX.Y.Z`) for every behavioural/template change.
- Ensure `bin/rex-codex --help` matches documented commands.
- Include `.codex_ci/` logs (or summaries) in PRs/notes for traceability.
- Verify templates (`templates/AGENTS.md`, `templates/documents/feature_cards/README.md`, enforcement tests) reflect new behaviour before cutting a release.

Keep the guardrails tight, prefer explicit documentation, and remember every change should reduce ambiguity for future Codex audits.***

=== /media/skynet3/8tb_a1/rex_codex_agent/README.md ===
# rex_codex_agent

Codex-first automation scaffold for **Python projects on Linux**. Drop the wrapper into a repo, describe work in Feature Cards, and the agent will:

- Generate **deterministic pytest specs** (tests only) from those cards.
- Run a disciplined **discriminator ladder** (smoke/unit → coverage ≥80% → optional security/package checks → style/type).
- Optionally nibble at runtime code with **tight guardrails** (small, allowlisted patches only).
- Capture logs, JUnit, and state in-repo so every pass is auditable.
- Dogfood itself with deterministic **self-development loops** (`scripts/selftest_loop.sh`, `scripts/smoke_e2e.sh`, and `bin/fake-codex`) so every change proves the generator → discriminator pipeline still works in a fresh repo.

> 🛠️ The agent intentionally targets **Linux shells (Bash 4+)**, **Python tooling**, and **OpenAI Codex** via `npx @openai/codex`. Windows support is via WSL; other ecosystems are out-of-scope.

`./rex-codex` is now a thin Bash shim that delegates to `python -m rex_codex`, so the orchestration logic (generator, discriminator, loop, card helpers) lives in Python modules that we can test and evolve directly.

---

## Requirements

- Linux (or WSL) with Bash 4+, `git`, and GNU `timeout` (Python handles advisory locks via `fcntl`).
- `python3` on PATH (the agent bootstraps a `.venv` with pytest/ruff/black/isort/flake8/mypy/pytest-cov).
- `node` 18+ if you want LLM-assisted generator/discriminator flows (the discriminator runs offline by default via `DISABLE_LLM=1`).
- Outbound network is optional: self-update now defaults **off** (`REX_AGENT_NO_UPDATE=1`). Flip to `0` to pull newer agent versions.
- For dogfooding, keep `bin/fake-codex` executable and run `scripts/selftest_loop.sh` (fast two-card loop) plus `scripts/smoke_e2e.sh` regularly—these harnesses prove the agent can install itself into a clean repo and go green without network access.

---

## Day-One Walkthrough

1. **Install the wrapper inside your repo**
   ```bash
   curl -fsSL https://raw.githubusercontent.com/rexdouglass/rex_codex_agent/main/scripts/install.sh | bash
   ```

2. **Bootstrap guardrails and tooling** *(the install step now runs these automatically; rerun anytime for assurance)*
   ```bash
   ./rex-codex init
   ./rex-codex doctor   # confirm python/node/docker availability
   ```

3. **Author a Feature Card**
   ```bash
   ./rex-codex card new       # guided prompts (writes documents/feature_cards/<slug>.md)
   ```
   Prefer the helper above—if you hand-edit, keep `status: proposed` on its own line and leave `## Links` / `## Spec Trace` empty so the generator can append to them later.
   The template in `templates/documents/feature_cards/README.md` shows the full heading layout the generator expects.

4. **Generate specs → run the ladder**
   ```bash
   ./rex-codex loop
   ```
   - **Generator** converts the card into deterministic pytest specs under `tests/feature_specs/<slug>/`.
   - Each generator pass opens with a dashboard summarising the Feature Card (title, acceptance criteria, existing specs) and previews the proposed diff with per-test highlights before patches land.
- **Discriminator** executes the staged ladder (health, smoke/unit, coverage ≥80%, optional pip-audit/bandit/build, style/type).
- Runs now finish with a color-coded loop summary so you can see at a glance whether generator/discriminator passed, warned, or failed and why.
- After each run, an audit snapshot is written to `for_external_GPT5_pro_audit/` and committed/pushed automatically so GPT5-Pro reviews have the latest scripts and docs.
   - Add `--explain` to preview the planned generator/discriminator phases before they run; `--no-self-update` skips the preflight update check.
   - Need a targeted rerun? `./rex-codex discriminator --feature-only` handles the shard; `./rex-codex discriminator --global` runs the full ladder.

5. **Implement runtime code until green**
   - Edit modules under `src/...` (or your package directories).
   - Re-run `./rex-codex loop --discriminator-only` for fast feedback.
   - Set `DISABLE_LLM=0` or add `--enable-llm` to allow the discriminator to propose tiny guarded runtime patches (requires `node`).

6. **Accept the feature**
   - When the discriminator is green, manually change the card to `status: accepted` and commit your work.

7. **Maintenance & lifecycle**
   - `./rex-codex status` – inspect the active slug/card and last discriminator success.
   - `./rex-codex logs` – tail the latest discriminator/generator output from `.codex_ci/`.
   - `./rex-codex card list` – list cards by status for quick triage.
   - `./rex-codex doctor` – diagnose env issues.
   - `./rex-codex install --force` – re-clone the agent and re-run `init`/`doctor` automatically (add `--skip-init` / `--skip-doctor` to opt out).
   - `./rex-codex burn --dry-run` then `--yes` – wipe repo contents (keeps `.git`, optionally `.rex_agent`).
   - `./rex-codex uninstall --force` – remove the agent (add `--keep-wrapper` to preserve the shim).

**Troubleshooting cheat sheet**
- `curl -fsSL https://raw.githubusercontent.com/rexdouglass/rex_codex_agent/main/scripts/install.sh | bash -s -- --force --channel main` – drop the latest agent into the current repo.
- `./rex-codex generator --tail 120` – replay Codex output and show the latest diff/log on failure (add `--quiet` to silence).
- `./rex-codex loop --tail 120` – run generator + discriminator with live diff previews and automatic log tails.
- `./rex-codex logs --generator --lines 200` – dump the most recent generator response/patch when you need manual inspection.
- `scripts/selftest_loop.sh` – fast offline selftest with two feature cards; export `SELFTEST_KEEP=1` to inspect `.selftest_workspace/`.
- `scripts/smoke_e2e.sh` – run the self-development loop end-to-end; set `KEEP=1` to preserve the temp repo for debugging.
- `GENERATOR_PROGRESS_SECONDS=5 ./rex-codex loop` – tighten the Codex heartbeat interval (default 15s) so long passes show more frequent progress updates.

---

## Command Overview

| Command | Purpose | Key Flags & Env |
|---------|---------|-----------------|
| `./rex-codex install` | Reinstall or refresh the agent in-place (auto-runs `init`/`doctor`). | `--force`, `--channel`, `--skip-init`, `--skip-doctor` |
| `./rex-codex init` | Seed `.venv`, guardrails, Feature Card scaffolding, and `rex-agent.json`. | — |
| `./rex-codex generator` | Generate deterministic pytest specs from the next `status: proposed` card. | `--single-pass`, `--max-passes`, `--focus`, `--status`, `--each`, `--tail`, `--quiet` |
| `./rex-codex discriminator` | Run the staged ladder (feature shard via `--feature-only`, full sweep by default). | `--feature-only`, `--global`, `--single-pass`, `--enable-llm`, `--disable-llm`, `DISCRIMINATOR_MAX_PASSES`, `COVERAGE_MIN`, `PIP_AUDIT`, `BANDIT`, `PACKAGE_CHECK`, `MYPY_TARGETS`, `MYPY_INCLUDE_TESTS`, `--tail`, `--quiet` |
| `./rex-codex loop` | Generator → feature shard → global sweep in one shot. | `--generator-only`, `--discriminator-only`, `--feature-only`, `--global-only`, `--each`, `--explain`, `--no-self-update`, `--enable-llm`, `--disable-llm`, `--tail`, `--quiet` |
| `./rex-codex card` | `new`, `list`, `validate` helpers for Feature Cards. | `--status`, `--acceptance` (for `new`) |
| `./rex-codex status` | Show the active slug/card and last discriminator success. | — |
| `./rex-codex logs` | Tail the latest generator/discriminator logs from `.codex_ci/`. | `--generator`, `--discriminator`, `--lines` |
| `./rex-codex doctor` | Print versions/paths for `python3`, `node`, and `docker`. | — |
| `./rex-codex burn` | Wipe the repo (keeps `.git`; optional `--purge-agent`; supports `--dry-run`). | `--yes`, `--purge-agent`, `--dry-run` |
| `./rex-codex uninstall` | Remove `.rex_agent/` and optionally the wrapper. | `--force`, `--keep-wrapper` |
| `./rex-codex self-update` | Refresh the agent when `REX_AGENT_NO_UPDATE=0`. | `--channel`, `REX_AGENT_CHANNEL` |

### Exit codes at a glance

| Command | Exit | Meaning |
|---------|------|---------|
| `generator` | 0 | Specs updated successfully. |
| `generator` | 1 | No matching Feature Card (or card path missing). |
| `generator` | 2 | Codex CLI errored; inspect `.codex_ci/generator_response.log`. |
| `generator` | 3 | Diff rejected (paths or patch-size budget). |
| `generator` | 4 | Patch application failed; manual merge required. |
| `generator` | 5 | Critic returned empty guidance. |
| `generator` | 6 | Max passes reached without a `DONE`. |
| `generator` | 7 | Guardrail rollback (card edit or hermetic failure). |
| `discriminator` | 0 | Ladder passed. |
| `discriminator` | 1 | Stage failed or max passes reached. |
| `discriminator` | 2 | LLM disabled or runtime patch rejected (see latest log). |

Artifacts land in `.codex_ci/`:
- `latest_discriminator.log` / `.codex_ci_latest.log` – tail of the latest run.
- `generator_tests.log` – pytest snapshot of generated specs.
- `discriminator_feature_<slug>.xml`, `discriminator_global_smoke.xml`, `discriminator_global_unit.xml` – JUnit results.
The agent also tracks state in `rex-agent.json` (active slug/card, last discriminator success).

---

## Generator (tests only, never runtime)

- Discovers cards by status; prompt instructs the Codex CLI to output a **unified diff** limited to `tests/feature_specs/<slug>/…` and the matching card.
- Prints a concise dashboard before each pass (Feature Card summary, acceptance criteria, existing specs) and a diff summary that calls out new/updated tests so you can see the plan at a glance.
- Warns when Feature Cards exist but their `status:` values miss the requested set (useful for catching typos like `propsed`).
- Before applying a diff it enforces:
  - Allowed-path filter.
  - Patch-size budget (`GENERATOR_MAX_FILES`, `GENERATOR_MAX_LINES`).
  - Hermeticity scan blocking network/clock/entropy/subprocess calls (e.g. `requests.get`, `subprocess.run`, `time.sleep`, `uuid.uuid4`, `secrets`, `numpy.random.*`).
  - Card guard: only appends in `## Links` / `## Spec Trace`, never mutates `status:`.
- After each pass it runs pytest on the spec shard and feeds logs to a “critic” loop until the card is marked `DONE` or max passes hit.
- Long Codex calls surface elapsed-time heartbeats (default every 15 seconds, configurable via `GENERATOR_PROGRESS_SECONDS`) so the loop never sits silent during a pass.

---

## Discriminator (quality ladder + guarded fixes)

Stages (feature or global):
1. Repo/system health (`git status -sb`, interpreter versions).
2. Tooling sanity (`python -c 'import pytest'`).
3. Smoke/unit grids (`pytest …`, parallel via `-n auto` when xdist present).
4. Coverage (default `COVERAGE_MIN=80`, targets default to `src/`).
5. Optional security/build gates (`pip-audit`, `bandit`, `python -m build` + `twine check`) driven by env flags.
6. Style/type (`black --check`, `isort --check-only`, `ruff check`, `flake8`, `mypy`).

Guardrails:
- Mechanical fixes (ruff/black/isort) run on runtime code only and auto-commit if they change anything.
- LLM runtime edits are **opt-in** (`DISABLE_LLM=0`) and obey protected-path hashing, runtime allowlists, patch-size limits, and “no shrinking tests”. Non-compliant diffs are reverted automatically.
- Each successful pass records a timestamp/slug/test-count in `rex-agent.json` for auditability.
- Every discriminator sweep ends with a colorized summary table (stage, identifier, duration, pass/fail) that includes the first failing log line and a suggested next command when something fails, making it easy to resume locally.

---

## Lifecycle Utilities & State

- `.rex_agent/` holds the agent sources; `.codex_ci/` holds run artifacts; `.codex_ci/*.lock` prevents concurrent commands from colliding.
- Templates (copied during `init`):
  - `AGENTS.md` – guardrails and operating guidance.
  - `documents/feature_cards/README.md` – how to structure cards.
  - `tests/enforcement/` – enforcement specs for repo hygiene.
- Self-update defaults off; set `REX_AGENT_NO_UPDATE=0` if you want automatic pulls (channels: `stable`, `main`, `<tag>`).

---

## Self-development Loop

- `bin/fake-codex` emulates `npx @openai/codex` and emits hermetic diffs limited to `tests/feature_specs/<slug>/`. Keep it executable so offline runs remain available.
- `scripts/selftest_loop.sh` resets `.selftest_workspace/`, installs the current checkout, exercises two feature cards (`hello_greet`, `hello_cli`) covering the default greeting and CLI flags, appends the command log/status/spec listing/runtime code to the latest audit file, then removes the workspace (set `SELFTEST_KEEP=1` to inspect).
- `scripts/smoke_e2e.sh` creates a throwaway repo, installs the current checkout via `scripts/install.sh`, scaffolds the `hello_greet` and `hello_cli` Feature Cards, and runs `./rex-codex loop --feature-only` followed by the global discriminator sweep (`KEEP=1` preserves the temp repo).
- Run the selftest loop before landing changes, bumping `VERSION`, or publishing docs; treat failures as release blockers. Follow up with the broader smoke harness as needed to validate longer paths.
- Once both pass, repeat the documented Golden Path in a fresh repo (e.g. your practice Pong game) to validate real-world usage with or without the Codex stub.

---

## Safety Rails & Defaults

- **Tests-first**: generator only writes specs; runtime edits must happen manually (or via the tightly constrained discriminator LLM pass).
- **Hermetic specs**: bans network/clock/entropy/subprocess calls, `skip`/`xfail`, and unseeded randomness.
- **Deterministic runs**: `PYTHONHASHSEED` defaults to `0`; pytest snapshots and discriminator stages honour configurable timeouts.
- **Patch-size limits**: generator and discriminator reject oversized diffs (defaults 6 files / 300 lines).
- **Protected paths**: tests, docs, configs, dependency manifests, CI, and the feature card are hashed before/after; unauthorized edits are reverted.
- **Coverage-first**: 80% minimum out of the box, captured via `pytest-cov`.
- **Optional gates**: enable `PIP_AUDIT=1`, `BANDIT=1`, `PACKAGE_CHECK=1` to bring security/build checks into the ladder.
- **Mypy scope**: type checking defaults to runtime targets (`MYPY_TARGETS` or `COVERAGE_TARGETS`); set `MYPY_INCLUDE_TESTS=1` to include spec shards when needed.
- **Concurrency-safe**: commands take out `.codex_ci/*.lock` using Python advisory (`fcntl`) locks.
- **Observability**: logs, JUnit XML, and recent state written to disk for CI ingestion and human review.

---

## Staying in the Guardrails

- The agent is purpose-built for **Python projects on Linux** with Codex as the LLM backend. Keep runtimes/tools in that lane for best results.
- When introducing new workflows or altering command behaviour, update `AGENTS.md`, this README, and the relevant templates before cutting a release.
- Version Tagged releases via `VERSION` ensure `REX_AGENT_CHANNEL=stable` installations stay reproducible.

Happy test-first hacking! For questions or contributions, open an issue/PR with the diff and attach the relevant `.codex_ci/` logs so reviewers can trace the run.***

=== /media/skynet3/8tb_a1/rex_codex_agent/documents/design_review.md ===
# rex_codex_agent Design Review

This document captures the current architecture, the rationale for migrating orchestration logic from shell to Python, and the intended end-to-end user experience. It is meant to keep expectations visible for future audits.

## 1. Current Posture

- **Purposeful constraints:** Linux shells (Bash 4+ or WSL), Python projects and tooling (pytest, mypy, ruff, black, isort, flake8) with coverage >=80 percent, and Codex as the LLM backend via `npx @openai/codex`. The agent is intentionally Python/Linux/Codex-specific.
- **Golden Path** is already documented: install the wrapper, run `init` and `doctor`, author Feature Cards, generate deterministic specs, pass the discriminator ladder, iterate, and finally accept the card. Guardrails include hermetic tests, patch budgets, and deterministic defaults.
- **Shell commands** today: `init`, `generator`, `discriminator`, `loop`, `supervise`, `uninstall`, and a gated `self-update`.
  - `init` bootstraps `.venv`, seeds templates, writes `rex-agent.json`, and enforces deterministic tool versions.
  - `generator` produces deterministic pytest specs in `tests/feature_specs/<slug>/`, appends to the Feature Card links/trace sections, and enforces hermetic AST checks and patch budgets (defaults: 6 files, 300 lines).
  - `discriminator` runs a staged ladder (health, tooling, smoke/unit shards, coverage >=80 percent, optional pip-audit/bandit/build, then style/type). Mechanical fixes are limited to runtime paths, and LLM runtime edits are off by default (`DISABLE_LLM=1`).
  - `loop` orchestrates generator -> discriminator with Python advisory (`fcntl`) locking, and mirrors flag passthrough from the underlying commands.
  - `install` provides an in-place refresh path (`--force` re-clones the agent) and now re-runs `init`/`doctor` automatically so the repo is ready immediately (opt out via `--skip-init` / `--skip-doctor`).
  - `supervise` is a thin wrapper over `loop`.
  - `uninstall` requires typing "remove agent" and honors `--keep-wrapper`.
  - `self-update` is opt-in and respects release channels via environment flags.

**Bottom line:** the current stack already delivers a disciplined, tests-first workflow with strong safety rails and reproducibility.

## 2. Architecture Direction (Shell vs. Python)

### Decision

Keep a thin Bash wrapper for installation ergonomics, but migrate orchestration logic into a Python package (`rex_codex`). The wrapper should drop into any repo and dispatch to `python -m rex_codex.cli`, preserving existing flags and behavior.

### Trade-offs

#### Bash (current)

- ✅ Minimal bootstrap friction; ideal for `curl | bash` installers; historical wrapper leveraged `flock`/`timeout`, while the Python CLI now owns locking via `fcntl`.
- ❌ Complex parsing, state management, and error handling are brittle; unit-testing is limited.
- ❌ The shell scripts already embed sizeable Python snippets (AST scanning, JSON edits), signalling that core logic wants a proper Python home.

#### Python (proposed)

- ✅ First-class support for testing, typing, logging, and state management; easier to express nuanced guardrails (protected-path hashing, hermetic scans, patch budgets).
- ✅ Enables richer UX (guided card creation, structured status/log outputs).
- ✅ Keeps guardrails centralized and testable.
- ❌ Requires Python to be present, but `.venv` bootstrapping already assumes it; retain the Bash shim to keep the drop-in experience.

### Recommendation

Adopt the hybrid approach: retain `./rex-codex` as a shell shim, but keep generator, discriminator, loop, doctor, burn, uninstall, and self-update inside the Python CLI so behavior can be tested and evolved safely.

## 3. User Journey (Idea -> Specs -> Runtime -> Quality Gates -> Iteration)

### Phase A: Idea to Deterministic Specs

1. **Install and bootstrap**
   ```bash
   curl -fsSL https://raw.githubusercontent.com/rexdouglass/rex_codex_agent/main/scripts/install.sh | bash
   ./rex-codex init
   ./rex-codex doctor
   ```
   `init` creates `.venv`, installs dev tooling, copies templates (`AGENTS.md`, pytest/mypy configs, enforcement tests), and seeds `rex-agent.json`. Documentation highlights the Linux/Python/Codex scope and the Golden Path.
2. **Author a Feature Card**
   - Run `./rex-codex card new` or hand-edit `documents/feature_cards/<slug>.md`.
   - Keep `status: proposed` on its own line; leave `## Links` and `## Spec Trace` empty so the generator can append.
3. **Generate deterministic specs (tests only)**
   ```bash
   ./rex-codex generator
   ```
   - Writes tests to `tests/feature_specs/<slug>/`.
   - Enforces patch budgets (defaults: 6 files, 300 lines) and hermetic AST scan (blocks network/time/entropy/subprocess **calls**, yet allows deterministic imports; unconditional skip/xfail remain forbidden).
   - Appends references to the Feature Card but never modifies `status:`.

### Phase B: Implement Runtime and Pass the Ladder

4. **Run the discriminator ladder**
   ```bash
   ./rex-codex discriminator --feature-only
   ./rex-codex discriminator --global
   ```
   Stages: health -> tooling -> smoke/unit -> coverage (>=80 percent, targets default to `src/`) -> optional security/build gates -> style/type (`black`, `isort`, `ruff`, `flake8`, `mypy`). Artifacts (logs, JUnit) live under `.codex_ci/`.
5. **Iterate on runtime code**
   - Implement features inside runtime allowlists (`src/...` or detected packages).
   - Use `./rex-codex loop --discriminator-only` for tight feedback.
   - Mechanical formatters can auto-fix runtime files; LLM runtime edits remain opt-in (enable with `--enable-llm` or `DISABLE_LLM=0`) and heavily constrained.
   - Type checking defaults to runtime targets via `MYPY_TARGETS` / `COVERAGE_TARGETS`; set `MYPY_INCLUDE_TESTS=1` when you need to type-check generated specs.

### Phase C: Changing Scope or Refining Requirements

6. **Refine acceptance criteria**
   - Edit the card while it remains `status: proposed` (or include accepted cards via flags).
   - Re-run the generator; it updates specs within guardrails and appends card links/trace.
   - Run the discriminator to validate the new requirements.
7. **Split or merge scope**
   - Create additional cards as needed (`card new`).
   - Use generator/discriminator status filters (`--include-accepted`, `--status`) to revisit accepted work when needed.
8. **Reset sandbox or uninstall**
   - `./rex-codex burn --dry-run` -> `./rex-codex burn --yes` to reset (preserves `.git`, optional `--purge-agent`).
   - `./rex-codex uninstall --force` removes the agent without prompts; add `--keep-wrapper` to retain the shim for a reinstall.

## 4. Python CLI UX Enhancements

The Python CLI enables ergonomics that were cumbersome in shell:

1. **Guided Feature Card workflow** (`card new`, `card list`, `card validate`) with prompts and linting.
2. **Single "do the right thing" command** via `loop`, showing a summary of the planned generator/discriminator stages.
3. **Better observability** through `status` (renders `rex-agent.json`) and `logs` (tails `.codex_ci/` artifacts).
4. **Explicit self-update controls** (`self-update --channel`, `REX_AGENT_NO_UPDATE`, `REX_AGENT_CHANNEL`).
5. **Explain mode** (`loop --explain`) to preview guardrails, patch budgets, and planned stages before execution.
6. **Verbose/tail diagnostics** (`generator --tail`, `loop --tail`, `logs --generator/--discriminator`) so engineers can inspect Codex output without copying files manually (add `--quiet` to silence).

## 5. Migration Plan

1. **Introduce the Python CLI package** (`rex_codex`) mirroring existing shell commands; re-home embedded Python snippets (AST scan, patch metrics, JSON state) into modules with tests.
2. **Convert `./rex-codex` into a thin shim** that locates the repo root, ensures Python is available, exports `PYTHONPATH` for the vendored sources, and calls `python -m rex_codex`.
3. **Expand UX** once parity is achieved: card helpers, `status`, `logs`, `self-update` surface, all while keeping default guardrails untouched (LLM off by default, coverage >=80 percent, patch budgets, hermetic specs).

## 6. Day-in-the-Life Scenario

1. Reinstall/refresh the agent (`curl … install.sh | bash -s -- --force --channel main` or `./rex-codex install --force --channel main`)—this now runs `./rex-codex init` and `./rex-codex doctor` automatically so the repo is seeded.
2. Create a card (`card new`) describing acceptance criteria (leave `status: proposed`).
3. Run `loop` to generate specs and execute the feature shard of the discriminator. Logs land in `.codex_ci/`.
4. Implement runtime code, rerunning `loop --discriminator-only` until green on feature and global stages.
5. Promote the card to `status: accepted` once the ladder passes.
6. When requirements change, update the card, rerun the generator, and iterate through the discriminator ladder again.
7. Optionally enable LLM runtime assistance by passing `--enable-llm` (or exporting `DISABLE_LLM=0`); guardrails still enforce runtime allowlists, patch budgets, and protected-path hashing. If Node is missing, the flow continues offline.
8. Use burn/uninstall flows to reset the environment or remove the agent entirely (`install --force` is available for re-cloning without a full uninstall).

## 7. Final Recommendation

- Adopt the hybrid architecture (shell shim + Python CLI) to align with the Python-first ecosystem, improve testability, and simplify future evolution.
- Preserve current guardrails and defaults: hermetic specs, protected paths, patch budgets, coverage >=80 percent, LLM disabled by default. These are the backbone of the tests-first, deterministic CI story and are reflected across README, AGENTS.md, and templates.
- Continue updating documentation (`README.md`, `AGENTS.md`, templates) whenever behavior or defaults change so future audits remain frictionless.

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/__init__.py ===
"""rex_codex Python package.

This package hosts the primary CLI implementation for the rex-codex agent.
The legacy Bash entrypoints now delegate to these modules so behaviour can be
unit-tested and extended directly in Python.
"""

from __future__ import annotations

from pathlib import Path


def _read_version() -> str:
    root = Path(__file__).resolve().parent.parent
    version_file = root / "VERSION"
    try:
        return version_file.read_text(encoding="utf-8").strip()
    except FileNotFoundError:
        return "0.0.0"


__all__ = ["__version__"]
__version__ = _read_version()


=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/__main__.py ===
"""Enable `python -m rex_codex`."""

from __future__ import annotations

from .cli import app


def main() -> None:  # pragma: no cover - exercised via Typer
    app()


if __name__ == "__main__":  # pragma: no cover
    main()


=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/burn.py ===
"""Implementation of `rex-codex burn`."""

from __future__ import annotations

import os
import shutil
from pathlib import Path

from .utils import RexContext, ask_confirmation, ensure_dir, repo_root


def burn_repo(
    *,
    force: bool,
    purge_agent: bool,
    dry_run: bool,
    context: RexContext | None = None,
) -> None:
    context = context or RexContext.discover()
    root = context.root
    agent_dir = root / ".rex_agent"

    print(f"WARNING: This will delete repository files in {root}")
    if purge_agent:
        print("  - .rex_agent will be removed")
    else:
        print("  - .rex_agent will be preserved")
    print("  - .git directory is always preserved")

    if dry_run:
        print("[burn] Dry-run mode: no files will be deleted.")
    elif not force:
        if not ask_confirmation("Type 'burn it down' to continue: ", expected="burn it down"):
            print("[burn] Aborted.")
            return

    entries = list(root.iterdir())
    for entry in entries:
        name = entry.name
        if name in {".", ".."}:
            continue
        if name in {".git", "rex-codex"}:
            continue
        if name == ".rex_agent" and not purge_agent:
            continue
        if dry_run:
            print(f"[dry-run] would remove: {entry}")
            continue
        if entry.is_dir():
            shutil.rmtree(entry)
        else:
            entry.unlink()

    if dry_run:
        print("[✓] Dry-run complete. No files were removed.")
        return

    ensure_dir(root)
    print("[✓] Repository reset. Re-run ./rex-codex init to seed fresh scaffolding.")


=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/cards.py ===
"""Feature card helpers."""

from __future__ import annotations

from datetime import UTC, datetime
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Optional, Sequence

from .utils import RexContext, dump_json, load_json, repo_root


CARD_DIR = Path("documents/feature_cards")
CARD_FILENAME_RE = re.compile(r"^[a-z0-9][a-z0-9_-]*$")
STATUS_RE = re.compile(r"^[ \t]*status:[ \t]*([A-Za-z0-9_.-]+)", re.IGNORECASE)


@dataclass
class FeatureCard:
    path: Path
    slug: str
    status: str

    @property
    def relative_path(self) -> Path:
        root = repo_root()
        try:
            return self.path.relative_to(root)
        except ValueError:
            return self.path


def card_directory(context: RexContext | None = None) -> Path:
    context = context or RexContext.discover()
    return context.root / CARD_DIR


def slug_from_filename(path: Path) -> str:
    stem = path.stem.lower()
    return stem


def read_status(path: Path) -> str:
    try:
        text = path.read_text(encoding="utf-8")
    except FileNotFoundError:
        return "missing"
    for line in text.splitlines():
        match = STATUS_RE.match(line)
        if match:
            return match.group(1).lower()
    return "unknown"


def discover_cards(
    statuses: Iterable[str] | None = None,
    *,
    context: RexContext | None = None,
) -> List[FeatureCard]:
    context = context or RexContext.discover()
    directory = card_directory(context)
    if not directory.exists():
        return []
    normalized_statuses = {s.lower() for s in (statuses or [])}
    matches: List[FeatureCard] = []
    for path in sorted(directory.glob("*.md")):
        slug = slug_from_filename(path)
        status = read_status(path)
        if normalized_statuses and status not in normalized_statuses:
            continue
        matches.append(FeatureCard(path, slug, status))
    return matches


def latest_card(statuses: Sequence[str] | None = None) -> Optional[FeatureCard]:
    cards = discover_cards(statuses)
    return cards[0] if cards else None


def load_rex_agent(context: RexContext | None = None) -> dict:
    context = context or RexContext.discover()
    return load_json(context.rex_agent_file)


def update_active_card(context: RexContext, *, card: FeatureCard | None) -> None:
    data = load_json(context.rex_agent_file)
    feature = data.setdefault("feature", {})
    if card:
        feature["active_card"] = str(card.relative_path)
        feature["active_slug"] = card.slug
    else:
        feature["active_card"] = None
        feature["active_slug"] = None
    dump_json(context.rex_agent_file, data)


def sanitise_slug(raw: str) -> str:
    slug = re.sub(r"[^a-z0-9_-]+", "-", raw.lower())
    slug = re.sub(r"-{2,}", "-", slug)
    slug = slug.strip("-_")
    slug = re.sub(r"^[^a-z0-9]+", "", slug)
    if not slug:
        slug = f"feature-{datetime.now(UTC):%Y%m%d%H%M%S}"
    return slug


def validate_slug(slug: str) -> None:
    if not slug:
        raise ValueError("slug cannot be empty")
    if not CARD_FILENAME_RE.match(slug):
        raise ValueError(
            "slug must contain lowercase letters, digits, hyphen, or underscore; "
            f"got {slug!r}"
        )


def create_card(
    context: RexContext,
    *,
    slug: str,
    title: str,
    summary: str,
    acceptance: Sequence[str],
) -> FeatureCard:
    validate_slug(slug)
    directory = card_directory(context)
    directory.mkdir(parents=True, exist_ok=True)
    path = directory / f"{slug}.md"
    if path.exists():
        raise FileExistsError(f"Feature Card already exists: {path}")
    body_lines = [
        "status: proposed",
        "",
        f"# {title.strip()}",
        "",
        "## Summary",
        "",
        summary.strip(),
        "",
        "## Acceptance Criteria",
    ]
    if acceptance:
        body_lines.append("")
        for item in acceptance:
            item = item.strip()
            if not item:
                continue
            if not item.startswith("- "):
                body_lines.append(f"- {item}")
            else:
                body_lines.append(item)
    else:
        body_lines.append("")
        body_lines.append("- TBD")
    body_lines.extend(
        [
            "",
            "## Links",
            "",
            "## Spec Trace",
            "",
        ]
    )
    path.write_text("\n".join(body_lines) + "\n", encoding="utf-8")
    card = FeatureCard(path=path, slug=slug, status="proposed")
    update_active_card(context, card=card)
    return card


def lint_card(path: Path) -> List[str]:
    errors: List[str] = []
    if not path.exists():
        return [f"{path}: missing file"]
    text = path.read_text(encoding="utf-8").splitlines()
    status_lines = [ln for ln in text if ln.lower().startswith("status:")]
    if not status_lines:
        errors.append(f"{path}: missing `status:` line")
    elif len(status_lines) > 1:
        errors.append(f"{path}: more than one `status:` line detected")
    headers = [ln.strip() for ln in text if ln.strip().startswith("## ")]
    expected = {"## Summary", "## Acceptance Criteria", "## Links", "## Spec Trace"}
    missing = expected.difference(headers)
    for header in sorted(missing):
        errors.append(f"{path}: missing header {header!r}")
    return errors


def lint_all_cards(context: RexContext | None = None) -> List[str]:
    context = context or RexContext.discover()
    directory = card_directory(context)
    errors: List[str] = []
    if not directory.exists():
        return ["No Feature Cards found; run `rex-codex card new` first."]
    for card in discover_cards(context=context):
        errors.extend(lint_card(card.path))
    return errors

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/cli.py ===
"""Command-line interface for rex-codex."""

from __future__ import annotations

import argparse
import sys
from pathlib import Path

from . import __version__
from .burn import burn_repo
from .cards import create_card, discover_cards, lint_all_cards, sanitise_slug
from .discriminator import DiscriminatorOptions, run_discriminator
from .doctor import run_doctor
from .generator import GeneratorOptions, parse_statuses, run_generator
from .init import run_init
from .install import run_install
from .logs import show_latest_logs
from .loop import LoopOptions, run_loop
from .self_update import self_update
from .status import render_status
from .uninstall import uninstall_agent
from .utils import RexContext, prompt


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="rex-codex", description="Codex automation scaffold")
    parser.add_argument("--version", action="version", version=f"rex-codex {__version__}")
    sub = parser.add_subparsers(dest="command")

    # install / init
    install_parser = sub.add_parser("install", help="Install or refresh the rex-codex agent")
    install_parser.add_argument("--force", action="store_true", help="Remove existing .rex_agent before installing")
    install_parser.add_argument("--channel", help="Install a specific channel/tag (e.g. stable, main)")
    install_parser.add_argument("--skip-init", action="store_true", help="Skip running ./rex-codex init after install")
    install_parser.add_argument("--skip-doctor", action="store_true", help="Skip running ./rex-codex doctor after install")

    init_parser = sub.add_parser("init", help="Seed guardrails and tooling")
    init_parser.add_argument("--no-self-update", action="store_true", help="Skip self-update before initializing")

    # generator
    gen_parser = sub.add_parser("generator", help="Generate deterministic specs for Feature Cards")
    gen_parser.add_argument("card", nargs="?", help="Feature Card path to focus on")
    gen_parser.add_argument("--single-pass", action="store_true", help="Run generator once and stop")
    gen_parser.add_argument("--max-passes", type=int, default=None, help="Maximum passes before giving up")
    gen_parser.add_argument("--focus", default="", help="Seed additional coverage focus")
    gen_parser.add_argument("--include-accepted", action="store_true", help="Consider cards with status: accepted")
    gen_parser.add_argument("--status", dest="statuses", default=None, help="Comma-separated statuses to include")
    gen_parser.add_argument("--each", action="store_true", help="Process each matching Feature Card sequentially")
    gen_parser.add_argument("--tail", type=int, default=0, help="Tail log output (N lines) when the generator fails")
    gen_verbose = gen_parser.add_mutually_exclusive_group()
    gen_verbose.add_argument("--verbose", action="store_true", help="Print Codex diffs (default)")
    gen_verbose.add_argument("--quiet", action="store_true", help="Suppress Codex diff output")

    # discriminator
    disc_parser = sub.add_parser("discriminator", help="Run the automation ladder")
    disc_mode = disc_parser.add_mutually_exclusive_group()
    disc_mode.add_argument("--feature-only", action="store_true", help="Run only the active feature shard")
    disc_mode.add_argument("--global", dest="global_only", action="store_true", help="Run the global sweep")
    disc_llm = disc_parser.add_mutually_exclusive_group()
    disc_llm.add_argument("--enable-llm", action="store_true", help="Allow guarded runtime edits via LLM")
    disc_llm.add_argument("--disable-llm", action="store_true", help="Disable LLM runtime edits (default)")
    disc_parser.add_argument("--single-pass", action="store_true", help="Run one pass and stop")
    disc_parser.add_argument("--max-passes", type=int, default=None, help="Maximum passes before giving up")
    disc_parser.add_argument("--feature", dest="feature_slug", help="Override feature slug")
    disc_verbose = disc_parser.add_mutually_exclusive_group()
    disc_verbose.add_argument("--verbose", action="store_true", help="Print discriminator debug output (default)")
    disc_verbose.add_argument("--quiet", action="store_true", help="Reduce discriminator verbosity")
    disc_parser.add_argument("--tail", type=int, default=0, help="Tail log output (N lines) when the discriminator fails")

    # loop
    loop_parser = sub.add_parser("loop", help="Generator → discriminator orchestration")
    loop_parser.add_argument("--skip-generator", action="store_true")
    loop_parser.add_argument("--generator-only", action="store_true")
    loop_parser.add_argument("--discriminator-only", action="store_true")
    loop_parser.add_argument("--skip-feature", action="store_true")
    loop_parser.add_argument("--skip-global", action="store_true")
    loop_parser.add_argument("--feature-only", action="store_true")
    loop_parser.add_argument("--global-only", action="store_true")
    loop_parser.add_argument("--include-accepted", action="store_true")
    loop_parser.add_argument("--status", dest="statuses", default=None)
    loop_parser.add_argument("--each", action="store_true", help="Process each matching Feature Card sequentially")
    loop_parser.add_argument("--no-self-update", action="store_true", help="Skip self-update before running")
    loop_parser.add_argument("--explain", action="store_true", help="Describe planned actions and exit")
    loop_verbose = loop_parser.add_mutually_exclusive_group()
    loop_verbose.add_argument("--verbose", action="store_true", help="Print generator/discriminator debug output (default)")
    loop_verbose.add_argument("--quiet", action="store_true", help="Reduce generator/discriminator output")
    loop_parser.add_argument("--tail", type=int, default=0, help="Tail log output (N lines) after failures")
    loop_llm = loop_parser.add_mutually_exclusive_group()
    loop_llm.add_argument("--enable-llm", action="store_true", help="Allow guarded runtime edits via LLM")
    loop_llm.add_argument("--disable-llm", action="store_true", help="Disable LLM runtime edits")

    # card commands
    card_parser = sub.add_parser("card", help="Feature Card helpers")
    card_sub = card_parser.add_subparsers(dest="card_command")
    card_new = card_sub.add_parser("new", help="Create a new Feature Card")
    card_new.add_argument("slug", nargs="?", help="Slug for the card (derived from title if omitted)")
    card_new.add_argument("--title", help="Human-friendly title")
    card_new.add_argument("--summary", help="Summary paragraph")
    card_new.add_argument("--acceptance", action="append", default=[], help="Acceptance criteria bullet (use multiple times)")

    card_list = card_sub.add_parser("list", help="List Feature Cards")
    card_list.add_argument("--status", dest="statuses", default=None, help="Comma separated statuses to filter")

    card_sub.add_parser("validate", help="Validate Feature Card formatting")

    # logs & status
    logs_parser = sub.add_parser("logs", help="Tail recent discriminator/generator logs")
    logs_parser.add_argument("--generator", action="store_true", help="Show generator logs")
    logs_parser.add_argument("--discriminator", action="store_true", help="Show discriminator logs")
    logs_parser.add_argument("--lines", type=int, default=120, help="Number of log lines to display")
    sub.add_parser("status", help="Show rex-codex status summary")

    # doctor
    sub.add_parser("doctor", help="Print environment diagnostics")

    # burn/uninstall
    burn_parser = sub.add_parser("burn", help="Reset repository contents (preserve .git)")
    burn_parser.add_argument("--yes", action="store_true", help="Skip confirmation")
    burn_parser.add_argument("--purge-agent", action="store_true", help="Remove .rex_agent as well")
    burn_parser.add_argument("--dry-run", action="store_true", help="Preview deletions without executing")

    uninstall_parser = sub.add_parser("uninstall", help="Remove the rex-codex agent")
    uninstall_parser.add_argument("--yes", "--force", action="store_true", dest="force", help="Skip confirmation")
    uninstall_parser.add_argument("--keep-wrapper", action="store_true", help="Preserve the ./rex-codex wrapper")

    # self-update
    update_parser = sub.add_parser("self-update", help="Force an agent self-update")
    update_parser.add_argument("--channel", choices=["stable", "main"], default=None, help="Update channel")

    return parser


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    context = RexContext.discover()

    if args.command == "install":
        run_install(
            force=args.force,
            channel=args.channel,
            run_init_after=not args.skip_init,
            run_doctor_after=not args.skip_doctor,
            context=context,
        )
        return 0

    if args.command == "init":
        run_init(context=context, perform_self_update=not args.no_self_update)
        return 0

    if args.command == "generator":
        options = GeneratorOptions()
        if args.single_pass:
            options.continuous = False
        if args.max_passes is not None:
            options.max_passes = args.max_passes
        options.focus = args.focus
        if args.statuses:
            options.statuses = parse_statuses(args.statuses)
        elif args.include_accepted:
            options.statuses.append("accepted")
        if args.card:
            options.card_path = Path(args.card)
        options.iterate_all = args.each
        options.verbose = not args.quiet
        if args.verbose:
            options.verbose = True
        options.tail_lines = args.tail
        exit_code = run_generator(options, context=context)
        if exit_code != 0 and args.tail:
            show_latest_logs(context, lines=args.tail, generator=True)
        return exit_code

    if args.command == "discriminator":
        options = DiscriminatorOptions()
        if args.feature_only:
            options.mode = "feature"
        elif args.global_only:
            options.mode = "global"
        if args.single_pass:
            options.continuous = False
        if args.max_passes is not None:
            options.max_passes = args.max_passes
        if args.feature_slug:
            options.slug = args.feature_slug
        if args.enable_llm:
            options.disable_llm = False
        elif args.disable_llm:
            options.disable_llm = True
        options.verbose = not args.quiet
        if args.verbose:
            options.verbose = True
        exit_code = run_discriminator(options, context=context)
        if exit_code != 0 and args.tail:
            show_latest_logs(context, lines=args.tail, discriminator=True)
        return exit_code

    if args.command == "loop":
        loop_opts = LoopOptions()
        if args.skip_generator:
            loop_opts.run_generator = False
        if args.generator_only:
            loop_opts.run_discriminator = False
        if args.discriminator_only:
            loop_opts.run_generator = False
        if args.skip_feature:
            loop_opts.run_feature = False
        if args.skip_global:
            loop_opts.run_global = False
        if args.feature_only:
            loop_opts.run_feature = True
            loop_opts.run_global = False
        if args.global_only:
            loop_opts.run_feature = False
            loop_opts.run_global = True
        if args.statuses:
            loop_opts.generator_options.statuses = parse_statuses(args.statuses)
        elif args.include_accepted:
            statuses = loop_opts.generator_options.statuses
            if "accepted" not in statuses:
                statuses.append("accepted")
        loop_opts.each_features = args.each
        loop_opts.perform_self_update = not args.no_self_update
        loop_opts.explain = args.explain
        loop_opts.verbose = not args.quiet
        if args.verbose:
            loop_opts.verbose = True
        loop_opts.tail_lines = args.tail
        if args.enable_llm:
            loop_opts.discriminator_options.disable_llm = False
        elif args.disable_llm:
            loop_opts.discriminator_options.disable_llm = True
        return run_loop(loop_opts, context=context)

    if args.command == "card":
        if args.card_command == "new":
            slug = args.slug
            title = args.title or prompt("Title: ")
            slug = slug or sanitise_slug(title)
            summary = args.summary or prompt("Summary: ")
            acceptance = args.acceptance or []
            if not acceptance:
                print("Enter acceptance criteria (blank line to finish):")
                while True:
                    item = prompt("- ")
                    if not item.strip():
                        break
                    acceptance.append(item.strip())
            card = create_card(context, slug=slug, title=title, summary=summary, acceptance=acceptance)
            print(f"[card] Created {card.path}")
            return 0
        if args.card_command == "list":
            statuses = parse_statuses(args.statuses) if args.statuses else None
            cards = discover_cards(statuses=statuses, context=context)
            if not cards:
                print("[card] No Feature Cards found.")
                return 0
            for card in cards:
                print(f"{card.status:>9}  {card.slug}  {card.path}")
            return 0
        if args.card_command == "validate":
            errors = lint_all_cards(context)
            if not errors:
                print("[card] All Feature Cards look good.")
                return 0
            for error in errors:
                print(error)
            return 1
        parser.error("card requires a sub-command (new/list/validate)")

    if args.command == "logs":
        show_latest_logs(
            context,
            lines=args.lines,
            generator=args.generator,
            discriminator=args.discriminator,
        )
        return 0

    if args.command == "status":
        render_status(context)
        return 0

    if args.command == "doctor":
        run_doctor()
        return 0

    if args.command == "burn":
        burn_repo(force=args.yes, purge_agent=args.purge_agent, dry_run=args.dry_run, context=context)
        return 0

    if args.command == "uninstall":
        uninstall_agent(force=args.force, keep_wrapper=args.keep_wrapper, context=context)
        return 0

    if args.command == "self-update":
        self_update(channel=args.channel)
        return 0

    parser.print_help()
    return 1


def app() -> None:  # pragma: no cover - Typer compatibility shim
    raise SystemExit(main())


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/config.py ===
"""Centralised configuration defaults for rex-codex."""

from __future__ import annotations

from .utils import agent_src, repo_root


REPO_ROOT = repo_root()
AGENT_SRC = agent_src(REPO_ROOT)
CODENAME = "rex-codex"
DEFAULT_GENERATOR_MAX_FILES = 6
DEFAULT_GENERATOR_MAX_LINES = 300
DEFAULT_DISCRIMINATOR_MAX_FILES = 6
DEFAULT_DISCRIMINATOR_MAX_LINES = 300
DEFAULT_COVERAGE_MIN = 80
DEFAULT_RUNTIME_ALLOWLIST = ("src",)
DEFAULT_PROTECTED_PATHS = [
    "tests",
    "documents",
    "pytest.ini",
    "pyproject.toml",
    "mypy.ini",
    ".flake8",
    ".ruff.toml",
    "ruff.toml",
    "conftest.py",
    "tox.ini",
    "setup.cfg",
    ".coveragerc",
    ".pre-commit-config.yaml",
    "requirements.txt",
    "requirements-dev.txt",
    "requirements",
    "constraints.txt",
    "constraints-*.txt",
    "constraints",
    "Pipfile",
    "Pipfile.lock",
    "poetry.lock",
    "Dockerfile",
    "Dockerfile.*",
    ".github",
    ".gitlab-ci.yml",
    ".gitlab",
    "Makefile",
    "noxfile.py",
]

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/discriminator.py ===
"""Staged automation ladder (discriminator) implemented in Python."""

from __future__ import annotations

import glob
import hashlib
import os
import re
import shlex
import shutil
import subprocess
import textwrap
import time
import sys
from dataclasses import dataclass, field
from pathlib import Path
from types import SimpleNamespace
from typing import Iterable, List, Optional, Sequence, Tuple
from collections import OrderedDict

from .cards import discover_cards, load_rex_agent
from .config import (
    AGENT_SRC,
    DEFAULT_COVERAGE_MIN,
    DEFAULT_DISCRIMINATOR_MAX_FILES,
    DEFAULT_DISCRIMINATOR_MAX_LINES,
    DEFAULT_PROTECTED_PATHS,
    DEFAULT_RUNTIME_ALLOWLIST,
)
from .generator import _split_command
from .self_update import self_update
from .utils import (
    RexContext,
    RexError,
    activate_venv,
    dump_json,
    ensure_dir,
    ensure_python,
    ensure_requirements_installed,
    load_json,
    lock_file,
    repo_root,
    run,
)


@dataclass
class DiscriminatorOptions:
    mode: str = "global"  # "feature" or "global"
    slug: Optional[str] = None
    continuous: bool = True
    max_passes: int = int(os.environ.get("DISCRIMINATOR_MAX_PASSES", "25"))
    disable_llm: bool = os.environ.get("DISABLE_LLM", "1") == "1"
    codex_bin: str = os.environ.get("CODEX_BIN", "npx --yes @openai/codex")
    codex_flags: str = os.environ.get("CODEX_FLAGS", "--yolo")
    codex_model: str = os.environ.get("MODEL", "")
    verbose: bool = True


@dataclass
class Stage:
    identifier: str
    description: str
    command: str


@dataclass
class StageGroup:
    title: str
    stages: List[Stage]


def _ansi_palette() -> SimpleNamespace:
    disable = bool(os.environ.get("NO_COLOR")) or not sys.stdout.isatty()
    if disable:
        return SimpleNamespace(
            green="",
            red="",
            yellow="",
            blue="",
            cyan="",
            magenta="",
            dim="",
            reset="",
            bold="",
            error="",
        )
    return SimpleNamespace(
        green="\x1b[32m",
        red="\x1b[31m",
        yellow="\x1b[33m",
        blue="\x1b[34m",
        cyan="\x1b[36m",
        magenta="\x1b[35m",
        dim="\x1b[2m",
        reset="\x1b[0m",
        bold="\x1b[1m",
        error="\x1b[31m",
    )


def run_discriminator(options: DiscriminatorOptions, *, context: RexContext | None = None) -> int:
    context = context or RexContext.discover()
    self_update()
    ensure_dir(context.codex_ci_dir)
    lock_path = context.codex_ci_dir / "rex_discriminator.lock"
    with lock_file(lock_path):
        return _run_locked(options, context)


def _run_locked(options: DiscriminatorOptions, context: RexContext) -> int:
    ensure_python(context, quiet=True)
    requirements_template = AGENT_SRC / "templates" / "requirements-dev.txt"
    ensure_requirements_installed(context, requirements_template)
    env = activate_venv(context)
    env.setdefault("PYTHONHASHSEED", "0")
    if "COVERAGE_TARGETS" not in env and (context.root / "src").exists():
        env["COVERAGE_TARGETS"] = "src"
    env.setdefault("COVERAGE_MIN", str(DEFAULT_COVERAGE_MIN))

    slug = options.slug or _discover_active_slug(context)
    mode = options.mode
    if mode == "feature" and not slug:
        print("[discriminator] No active feature slug; falling back to global sweep")
        mode = "global"

    log_path = context.codex_ci_dir / "latest_discriminator.log"
    latest_log_path = context.root / ".codex_ci_latest.log"
    if options.verbose:
        print(f"[discriminator] Logs will be written to {context.relative(log_path)}")

    passes = 0
    while passes < options.max_passes:
        passes += 1
        print(f"=== rex-codex discriminator ({mode}) pass {passes}/{options.max_passes} ===")
        log_path.write_text("", encoding="utf-8")
        latest_log_path.write_text("", encoding="utf-8")

        ok = _run_stage_plan(
            mode=mode,
            slug=slug,
            env=env,
            context=context,
            log_path=log_path,
            latest_log_path=latest_log_path,
        )
        if ok:
            print(f"✅ Green: {mode} suite passed")
            _record_success(mode, slug, context, env)
            return 0

        if not options.continuous:
            print("[discriminator] Stopping after first failing pass (--single-pass).")
            return 1

        # Mechanical fixes
        if _apply_mechanical_fixes(mode, slug, context, env):
            if _run_stage_plan(
                mode=mode,
                slug=slug,
                env=env,
                context=context,
                log_path=log_path,
                latest_log_path=latest_log_path,
            ):
                print("✅ Green after mechanical fixes")
                _record_success(mode, slug, context, env)
                return 0

        if options.disable_llm:
            print("LLM disabled; stopping after mechanical fixes.")
            return 2

        if not _ensure_node_present():
            print("[discriminator] Node.js not found; forcing DISABLE_LLM=1.")
            return 2

        test_count_before = _collect_test_count(mode, slug, context, env)
        snapshot = _snapshot_protected_paths(context)
        _invoke_llm_once(options, mode, slug, context, env, log_path, latest_log_path)

        changed = _detect_protected_changes(snapshot, context)
        if changed:
            print("[discriminator] Aborting pass; LLM patch touched protected paths.")
            _revert_paths(changed, context)
            return 2

        if not _reject_non_runtime_changes(context):
            print("[discriminator] Aborting pass; LLM patch touched non-runtime paths.")
            _revert_all_changes(context)
            return 2

        if _git_diff_is_empty(context):
            print("No diff from LLM; aborting.")
            return 2

        test_count_after = _collect_test_count(mode, slug, context, env)
        if (
            test_count_before is not None
            and test_count_after is not None
            and test_count_after < test_count_before
        ):
            print(
                f"[discriminator] Test collection decreased ({test_count_before} -> {test_count_after}); rejecting LLM patch."
            )
            _revert_all_changes(context)
            return 2

        if not _enforce_patch_size(context):
            print("[discriminator] Aborting pass; LLM patch exceeded size limits.")
            return 2

        run(["git", "add", "-A"], cwd=context.root, check=False)
        run(
            ["git", "commit", "-m", f"chore(rex-codex): discriminator {mode} pass {passes}"],
            cwd=context.root,
            check=False,
        )
        _record_success(mode, slug, context, env)
    print(f"Hit max passes ({options.max_passes}) without going green")
    return 1


def _discover_active_slug(context: RexContext) -> Optional[str]:
    data = load_rex_agent(context)
    feature = data.get("feature", {})
    slug = feature.get("active_slug")
    if slug:
        return slug
    cards = discover_cards(statuses=["proposed"], context=context)
    return cards[0].slug if cards else None


def _run_stage_plan(
    *,
    mode: str,
    slug: Optional[str],
    env: dict[str, str],
    context: RexContext,
    log_path: Path,
    latest_log_path: Path,
) -> bool:
    pytest_flags = _configure_pytest_flags(mode, env, context)
    specs_dir = context.root / "tests" / "feature_specs" / (slug or "")
    palette = _ansi_palette()
    if mode == "feature":
        if not slug:
            print("[discriminator] Feature mode requested but no slug provided.")
            return False
        if not specs_dir.is_dir():
            msg = f"[discriminator] Feature specs directory {specs_dir} missing"
            print(msg)
            with open(latest_log_path, "a", encoding="utf-8") as fh:
                fh.write(msg + "\n")
            return False

    groups = _build_stage_groups(mode, slug, pytest_flags, env, context)
    overall_ok = True
    summary: List[dict[str, object]] = []
    first_failure: Optional[dict[str, object]] = None
    for group in groups:
        print("------------------------------------------------------------")
        print(f"{palette.blue}Stage: {group.title}{palette.reset}")
        for stage in group.stages:
            if stage.command.strip() == "":
                continue
            ok, elapsed, tail = _execute_stage(stage, env, context, log_path, latest_log_path)
            status = f"{palette.green}PASS{palette.reset}" if ok else f"{palette.red}FAIL{palette.reset}"
            timing = f"{palette.dim}({elapsed:.2f}s){palette.reset}"
            print(f"    {palette.dim}[{stage.identifier}]{palette.reset} {status} {timing}")
            record = {
                "group": group.title,
                "identifier": stage.identifier,
                "description": stage.description,
                "command": stage.command,
                "elapsed": elapsed,
                "ok": ok,
                "tail": tail,
            }
            summary.append(record)
            if not ok:
                overall_ok = False
                if first_failure is None:
                    first_failure = record
    result = f"{palette.green}PASS{palette.reset}" if overall_ok else f"{palette.red}FAIL{palette.reset}"
    print(f"  Result: [{result}]")
    _render_stage_summary(summary, overall_ok, first_failure, palette)
    return overall_ok


def _configure_pytest_flags(mode: str, env: dict[str, str], context: RexContext) -> List[str]:
    flags = ["-q", "-ra"]
    if mode == "feature":
        flags += ["-x", "--maxfail=1"]
        return flags
    probe = run(
        ["python", "-c", "import importlib.util, sys; sys.exit(0 if importlib.util.find_spec('xdist') else 1)"],
        env=env,
        cwd=context.root,
        check=False,
        capture_output=True,
    )
    if probe.returncode == 0:
        flags += ["-n", "auto", "--dist", "loadscope"]
    return flags


def _build_stage_groups(
    mode: str,
    slug: Optional[str],
    pytest_flags: Sequence[str],
    env: dict[str, str],
    context: RexContext,
) -> List[StageGroup]:
    pytest_flags_str = " ".join(shlex.quote(flag) for flag in pytest_flags)
    specs_dir = f"tests/feature_specs/{slug}" if slug else ""
    coverage_min = env.get("COVERAGE_MIN")
    coverage_targets = env.get("COVERAGE_TARGETS", ".")

    def _format_targets(raw: str) -> str:
        tokens = [token for token in re.split(r"[,\s]+", raw.strip()) if token]
        return " ".join(shlex.quote(token) for token in tokens) or "."

    if env.get("MYPY_TARGETS"):
        mypy_raw = env["MYPY_TARGETS"]
    elif env.get("COVERAGE_TARGETS"):
        mypy_raw = env["COVERAGE_TARGETS"]
    elif (context.root / "src").exists():
        mypy_raw = "src"
    else:
        mypy_raw = "."
    mypy_targets = _format_targets(mypy_raw)
    groups: List[StageGroup] = []

    level00 = StageGroup(
        title="Level 00 - Repo & System Health",
        stages=[
            Stage("00.1", "Git status", "git status -sb"),
            Stage("00.2", "Python version", "python3 --version"),
        ],
    )
    if (context.root / ".venv" / "bin" / "python").exists():
        level00.stages.append(Stage("00.3", "Venv Python", ".venv/bin/python --version"))
    groups.append(level00)

    groups.append(
        StageGroup(
            title="Level 01 - Tooling & Dependencies",
            stages=[
                Stage("01.1", "pytest importable?", "python -c 'import pytest; print(pytest.__version__)'"),
            ],
        )
    )

    if mode == "feature":
        groups.append(
            StageGroup(
                title=f"Level 02 - Feature Spec Smoke ({slug})",
                stages=[
                    Stage(
                        "02.1",
                        "Run feature specs",
                        f"pytest {pytest_flags_str} {shlex.quote(specs_dir)} --junitxml .codex_ci/discriminator_feature_{slug}.xml",
                    )
                ],
            )
        )
        groups.append(
            StageGroup(
                title=f"Level 03 - Feature Unit Grid ({slug})",
                stages=[
                    Stage(
                        "03.1",
                        "Run feature specs (no DB markers)",
                        f"pytest {pytest_flags_str} {shlex.quote(specs_dir)} -m 'not django_db'",
                    )
                ],
            )
        )
        if coverage_min:
            groups.append(
                StageGroup(
                    title=f"Level 04 - Feature Coverage ({slug})",
                    stages=[
                        Stage(
                            "04.1",
                            "Coverage threshold",
                            f"pytest {pytest_flags_str} {shlex.quote(specs_dir)} --cov={coverage_targets} --cov-report=term --cov-fail-under={coverage_min}",
                        )
                    ],
                )
            )
    else:
        groups.append(
            StageGroup(
                title="Level 02 - Inline Spec Smoke",
                stages=[
                    Stage(
                        "02.1",
                        "Do doctests/specs pass?",
                        f"pytest {pytest_flags_str} -k 'spec or doctest' --junitxml .codex_ci/discriminator_global_smoke.xml",
                    )
                ],
            )
        )
        groups.append(
            StageGroup(
                title="Level 03 - Unit Test Grid",
                stages=[
                    Stage(
                        "03.1",
                        "Run unit tests (no DB markers)",
                        f"pytest {pytest_flags_str} -m 'not django_db' --junitxml .codex_ci/discriminator_global_unit.xml",
                    )
                ],
            )
        )
        if coverage_min:
            groups.append(
                StageGroup(
                    title="Level 04 - Coverage",
                    stages=[
                        Stage(
                            "04.1",
                            "Coverage threshold",
                            f"pytest {pytest_flags_str} --cov={coverage_targets} --cov-report=term --cov-fail-under={coverage_min}",
                        )
                    ],
                )
            )

    level05_stages: List[Stage] = []
    if env.get("PIP_AUDIT") == "1":
        level05_stages.append(
            Stage(
                "05.1",
                "pip-audit (dependencies)",
                "python -m pip install -q pip-audit >/dev/null 2>&1 && pip-audit",
            )
        )
    if env.get("BANDIT") == "1":
        bandit_targets = env.get("BANDIT_TARGETS") or env.get("COVERAGE_TARGETS") or "src"
        if not (context.root / bandit_targets).exists():
            bandit_targets = "."
        level05_stages.append(
            Stage(
                "05.2",
                "bandit (static security)",
                f"python -m pip install -q bandit >/dev/null 2>&1 && bandit -q -r {bandit_targets}",
            )
        )
    if env.get("PACKAGE_CHECK") == "1":
        level05_stages.extend(
            [
                Stage(
                    "05.3",
                    "Build distribution artifacts",
                    "python -m pip install -q build twine >/dev/null 2>&1 && python -m build",
                ),
                Stage(
                    "05.4",
                    "twine check dist/*",
                    "python -m pip install -q build twine >/dev/null 2>&1 && twine check dist/*",
                ),
            ]
        )
    if level05_stages:
        groups.append(StageGroup(title="Level 05 - Security & Build", stages=level05_stages))

    if mode == "feature":
        target = shlex.quote(specs_dir)
        feature_style_stages = [
            Stage("06.1", "black --check (feature)", f"black {target} --check"),
            Stage("06.2", "isort --check-only (feature)", f"isort {target} --check-only"),
            Stage("06.3", "ruff check (feature)", f"ruff check {target}"),
            Stage("06.4", "flake8 (feature)", f"flake8 {target}"),
        ]
        if env.get("MYPY_INCLUDE_TESTS") == "1":
            feature_style_stages.append(Stage("06.5", "mypy (feature)", f"mypy {target}"))
        groups.append(
            StageGroup(
                title=f"Level 06 - Feature Style & Type Gates ({slug})",
                stages=feature_style_stages,
            )
        )
    else:
        groups.append(
            StageGroup(
                title="Level 06 - Style & Type Gates",
                stages=[
                    Stage("06.1", "black --check", "black . --check"),
                    Stage("06.2", "isort --check-only", "isort . --check-only"),
                    Stage("06.3", "ruff check", "ruff check ."),
                    Stage("06.4", "flake8", "flake8 ."),
                    Stage("06.5", "mypy", f"mypy {mypy_targets}"),
                ],
            )
        )
    return groups


def _execute_stage(
    stage: Stage,
    env: dict[str, str],
    context: RexContext,
    log_path: Path,
    latest_log_path: Path,
) -> Tuple[bool, float, str]:
    print(f"\n  Question {stage.identifier}: {stage.description}")
    print(f"    Command: {stage.command}")
    stage_timeout = int(os.environ.get("DISCRIMINATOR_STAGE_TIMEOUT", "0") or "0")
    timeout_seconds = stage_timeout if stage_timeout > 0 else None
    cmd = ["bash", "-lc", stage.command]
    start = time.perf_counter()
    try:
        completed = subprocess.run(
            cmd,
            cwd=context.root,
            env=env,
            capture_output=True,
            text=True,
            timeout=timeout_seconds,
        )
        output = (completed.stdout or "") + (completed.stderr or "")
    except subprocess.TimeoutExpired:
        message = f"[discriminator] Stage {stage.identifier} timed out after {stage_timeout}s"
        output = message + "\n"
        completed = subprocess.CompletedProcess(cmd, returncode=124, stdout="", stderr=message)
    elapsed = time.perf_counter() - start
    with open(log_path, "a", encoding="utf-8") as fh:
        fh.write(f"\n[{stage.identifier}] {stage.description}\n")
        fh.write(output)
    with open(latest_log_path, "a", encoding="utf-8") as fh:
        fh.write(output)
    print(output, end="")
    if completed.returncode == 124:
        print(f"[discriminator] Stage {stage.identifier} timed out after {stage_timeout}s")
    ok = completed.returncode == 0
    tail_lines = "\n".join((output or "").splitlines()[-8:])
    return ok, elapsed, tail_lines


def _render_stage_summary(
    summary: List[dict[str, object]],
    overall_ok: bool,
    first_failure: Optional[dict[str, object]],
    palette: SimpleNamespace,
) -> None:
    if not summary:
        return
    print("\n--- Summary -----------------------------------------------------")
    grouped: "OrderedDict[str, List[dict[str, object]]]" = OrderedDict()
    for record in summary:
        key = record["group"]  # type: ignore[index]
        grouped.setdefault(key, []).append(record)
    for group, rows in grouped.items():
        print(f"{palette.bold}{group}{palette.reset}")
        for record in rows:
            ok = bool(record["ok"])
            icon = f"{palette.green}✔{palette.reset}" if ok else f"{palette.red}✖{palette.reset}"
            identifier = record["identifier"]
            description = record["description"]
            elapsed = float(record["elapsed"])
            timing = f"{palette.dim}({elapsed:.2f}s){palette.reset}"
            print(f"  {icon} {palette.dim}[{identifier}]{palette.reset} {description} {timing}")
            if not ok:
                reason = _summarize_failure_reason(record.get("tail", ""))
                if reason:
                    print(f"      ↳ {palette.error}{reason}{palette.reset}")
    if not overall_ok and first_failure is not None:
        command = first_failure["command"]
        print(f"\n{palette.yellow}Next step:{palette.reset} rerun the first failing command locally:")
        print(f"  {command}")
        print(f"Inspect {palette.cyan}./rex-codex logs --discriminator --lines 200{palette.reset} for full output.")


def _summarize_failure_reason(tail: object) -> str:
    text = str(tail or "")
    for line in text.splitlines():
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.lower().startswith("bringing up nodes"):
            continue
        if stripped.startswith("SKIPPED "):
            continue
        return stripped[:160]
    return ""


def shutil_which(name: str) -> Optional[str]:
    from shutil import which

    return which(name)


def _ensure_node_present() -> bool:
    return shutil_which("node") is not None


def _collect_test_count(
    mode: str,
    slug: Optional[str],
    context: RexContext,
    env: dict[str, str],
) -> Optional[int]:
    cmd = ["pytest", "--collect-only"]
    if mode == "feature" and slug:
        specs_dir = context.root / "tests" / "feature_specs" / slug
        if specs_dir.is_dir():
            cmd.append(str(specs_dir))
    completed = run(cmd, cwd=context.root, env=env, capture_output=True, check=False)
    text = (completed.stdout or "") + (completed.stderr or "")
    match = re.search(r"collected (\d+) items?", text, re.IGNORECASE)
    if not match:
        return None
    try:
        return int(match.group(1))
    except ValueError:
        return None


def _protected_patterns() -> List[str]:
    raw = os.environ.get("DISCRIMINATOR_PROTECTED_PATHS")
    if raw:
        return [token for token in raw.split() if token.strip()]
    return list(DEFAULT_PROTECTED_PATHS)


def _snapshot_protected_paths(context: RexContext) -> dict[str, str]:
    patterns = _protected_patterns()
    root = context.root
    files: set[Path] = set()

    def record_path(path: Path) -> None:
        if not path.exists():
            return
        if path.is_dir():
            for child in path.rglob("*"):
                if child.is_file():
                    files.add(child)
        elif path.is_file():
            files.add(path)

    for pattern in patterns:
        if not pattern:
            continue
        full_pattern = root / pattern
        matches = glob.glob(str(full_pattern), recursive=True)
        if not matches and not any(ch in pattern for ch in "*?[]"):
            candidate = root / pattern
            if candidate.exists():
                matches = [str(candidate)]
        for match in matches:
            record_path(Path(match))

    snapshot: dict[str, str] = {}
    for file_path in sorted(files):
        try:
            digest = hashlib.sha256(file_path.read_bytes()).hexdigest()
        except OSError:
            continue
        snapshot[str(file_path.relative_to(root))] = digest
    return snapshot


def _detect_protected_changes(baseline: dict[str, str], context: RexContext) -> List[str]:
    current = _snapshot_protected_paths(context)
    changed: set[str] = set()
    for path, digest in baseline.items():
        if path not in current:
            changed.add(path)
        elif current[path] != digest:
            changed.add(path)
    for path in current:
        if path not in baseline:
            changed.add(path)
    return sorted(changed)


def _revert_paths(paths: Iterable[str], context: RexContext) -> None:
    for path in paths:
        target = context.root / path
        result = run(
            ["git", "ls-files", "--error-unmatch", path],
            cwd=context.root,
            capture_output=True,
            check=False,
        )
        if result.returncode == 0:
            run(["git", "restore", "--staged", "--", path], cwd=context.root, check=False)
            run(["git", "restore", "--worktree", "--", path], cwd=context.root, check=False)
        elif target.exists():
            if target.is_dir():
                shutil.rmtree(target)
            else:
                target.unlink()


def _revert_all_changes(context: RexContext) -> None:
    result = run(
        ["git", "restore", "--staged", "--worktree", "--source=HEAD", ":/"],
        cwd=context.root,
        check=False,
    )
    if result.returncode != 0:
        run(["git", "reset", "--hard", "-q"], cwd=context.root, check=False)


def _reject_non_runtime_changes(context: RexContext) -> bool:
    runtime_targets = _detect_runtime_targets(context)
    if not runtime_targets:
        return True
    changed = run(
        ["bash", "-lc", "git diff --name-only; git ls-files --others --exclude-standard"],
        cwd=context.root,
        capture_output=True,
        check=False,
    ).stdout.splitlines()
    rejects: List[str] = []
    for path in sorted(set(changed)):
        if not path or path.startswith(".codex_ci/"):
            continue
        allowed = any(path == target or path.startswith(f"{target}/") for target in runtime_targets)
        if not allowed:
            rejects.append(path)
    if rejects:
        print(f"[discriminator] LLM edits outside runtime allowlist: {' '.join(rejects)}")
        _revert_paths(rejects, context)
        return False
    return True


def _git_diff_is_empty(context: RexContext) -> bool:
    result = run(["git", "diff", "--quiet"], cwd=context.root, check=False)
    return result.returncode == 0


def _enforce_patch_size(context: RexContext) -> bool:
    max_files = int(os.environ.get("DISCRIMINATOR_MAX_FILES", DEFAULT_DISCRIMINATOR_MAX_FILES))
    max_lines = int(os.environ.get("DISCRIMINATOR_MAX_LINES", DEFAULT_DISCRIMINATOR_MAX_LINES))
    completed = run(["git", "diff", "--numstat"], cwd=context.root, capture_output=True, check=False)
    files = 0
    lines = 0
    for line in completed.stdout.splitlines():
        parts = line.split()
        if len(parts) < 3:
            continue
        added, deleted = parts[0], parts[1]
        if added == "-" or deleted == "-":
            files += 1
            lines += max_lines + 1
            continue
        try:
            files += 1
            lines += int(added) + int(deleted)
        except ValueError:
            continue
    if files > max_files or lines > max_lines:
        print(
            f"[discriminator] LLM patch touched {files} files / {lines} lines "
            f"(limits {max_files}/{max_lines})."
        )
        _revert_all_changes(context)
        return False
    return True


def _apply_mechanical_fixes(
    mode: str,
    slug: Optional[str],
    context: RexContext,
    env: dict[str, str],
) -> bool:
    print("Mechanical fixes (ruff/black/isort)…")
    if mode == "feature":
        if not slug:
            return False
        target = context.root / "tests" / "feature_specs" / slug
        if not target.is_dir():
            print("[discriminator] No feature specs directory; skipping mechanical fixes.")
            return False
        targets = [str(target)]
    else:
        targets = _detect_runtime_targets(context)
        if not targets:
            print("[discriminator] No runtime targets detected for mechanical style; skipping.")
            return False
    run(["ruff", "check", *targets, "--fix"], cwd=context.root, env=env, check=False)
    run(["black", *targets], cwd=context.root, env=env, check=False)
    run(["isort", *targets], cwd=context.root, env=env, check=False)
    if _git_diff_is_empty(context):
        return False
    run(["git", "add", "-A"], cwd=context.root, check=False)
    label = "feature" if mode == "feature" else "global"
    run(["git", "commit", "-m", f"style(rex-codex): apply ruff/black/isort ({label})"], cwd=context.root, check=False)
    return True


def _detect_runtime_targets(context: RexContext) -> List[str]:
    overrides = os.environ.get("DISCRIMINATOR_RUNTIME_ALLOWLIST")
    if overrides:
        runtime = sorted({token.strip() for token in overrides.split() if token.strip()})
        return runtime
    root = context.root
    targets: set[str] = set()
    for default in DEFAULT_RUNTIME_ALLOWLIST:
        candidate = root / default
        if candidate.exists():
            targets.add(default)
    for pkg_init in root.glob("*/__init__.py"):
        pkg_dir = pkg_init.parent
        name = pkg_dir.name
        if name in {"tests", "test", "documents", "docs", ".git", ".github"}:
            continue
        targets.add(name)
    return sorted(targets)


def _tail_text(path: Path, lines: int = 120) -> str:
    if not path.exists():
        return ""
    content = path.read_text(encoding="utf-8", errors="replace").splitlines()
    return "\n".join(content[-lines:])


def _invoke_llm_once(
    options: DiscriminatorOptions,
    mode: str,
    slug: Optional[str],
    context: RexContext,
    env: dict[str, str],
    log_path: Path,
    latest_log_path: Path,
) -> None:
    runtime_allowlist = _detect_runtime_targets(context)
    agents_path = context.root / "AGENTS.md"
    agents_excerpt = ""
    if agents_path.exists():
        agents_excerpt = "\n".join(agents_path.read_text(encoding="utf-8", errors="replace").splitlines()[:300])
    log_excerpt = _tail_text(log_path) or _tail_text(latest_log_path)

    prompt_lines = [
        "You are a coding agent for this repository.",
        "Follow AGENTS.md guardrails (runtime vs tests, doc/spec/type, offline by default).",
        "Make ONE minimal change that most reduces non-compliance or failures.",
        "Do not weaken tests or remove functionality.",
        "After edits, run relevant commands locally to validate.",
        "",
        f"Current discriminator mode: {mode}",
    ]
    if slug:
        prompt_lines.append(f"Active feature slug: {slug}")
    prompt_lines.extend([
        "",
        "Runtime directories permitted for edits:",
    ])
    if runtime_allowlist:
        prompt_lines.extend([f" - {target}" for target in runtime_allowlist])
    else:
        prompt_lines.append(" - (none discovered; edits outside protected files likely to be rejected)")
    prompt_lines.extend([
        "",
        "--- BEGIN AGENTS.md EXCERPT ---",
        agents_excerpt,
        "--- END AGENTS.md EXCERPT ---",
    ])
    if log_excerpt:
        prompt_lines.extend([
            "",
            "Latest log excerpt:",
            "```",
            log_excerpt,
            "```",
        ])
    prompt_text = "\n".join(prompt_lines)
    prompt_file = context.codex_ci_dir / "discriminator_prompt.txt"
    prompt_file.write_text(prompt_text + "\n", encoding="utf-8")

    cmd = (
        _split_command(options.codex_bin)
        + ["exec"]
        + _split_command(options.codex_flags)
    )
    if options.codex_model:
        cmd += ["--model", options.codex_model]
    cmd += ["--cd", str(context.root), "--", prompt_text]

    print(f"[*] Invoking Codex with: {' '.join(cmd)}")
    completed = subprocess.run(
        cmd,
        cwd=context.root,
        env=env,
        capture_output=True,
        text=True,
    )
    log_file = context.codex_ci_dir / "discriminator_llm_response.log"
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    with open(log_file, "a", encoding="utf-8") as fh:
        fh.write(f"=== {timestamp} ===\n")
        fh.write((completed.stdout or "") + (completed.stderr or ""))
        fh.write("\n")


def _record_success(
    mode: str,
    slug: Optional[str],
    context: RexContext,
    env: dict[str, str],
) -> None:
    data = load_json(context.rex_agent_file)
    disc = data.setdefault("discriminator", {})
    disc["last_mode"] = mode
    disc["last_slug"] = slug
    disc["last_green_at"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    test_count = _collect_test_count(mode, slug, context, env)
    if test_count is not None:
        disc["last_test_count"] = test_count
    dump_json(context.rex_agent_file, data)

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/doctor.py ===
"""Diagnostics for rex-codex."""

from __future__ import annotations

from .utils import which


TOOLS = ("python3", "node", "npx", "docker")


def run_doctor() -> None:
    for tool in TOOLS:
        path = which(tool)
        if path:
            print(f"[doctor] {tool}: {path}")
        else:
            print(f"[doctor] {tool}: missing (install or add to PATH)")

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/generator.py ===
"""Deterministic spec generator implemented in Python."""

from __future__ import annotations

import difflib
import os
import re
import subprocess
import sys
import tempfile
import textwrap
import time
from collections import defaultdict
from dataclasses import dataclass, field
from pathlib import Path
from types import SimpleNamespace
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

from .cards import FeatureCard, discover_cards, load_rex_agent, update_active_card
from .config import (
    AGENT_SRC,
    DEFAULT_GENERATOR_MAX_FILES,
    DEFAULT_GENERATOR_MAX_LINES,
    REPO_ROOT,
)
from .self_update import self_update
from .utils import (
    RexContext,
    RexError,
    activate_venv,
    dump_json,
    ensure_dir,
    ensure_python,
    ensure_requirements_installed,
    lock_file,
    load_json,
    print_header,
    repo_root,
    run,
)

PROGRESS_INTERVAL_SECONDS = max(5, int(os.environ.get("GENERATOR_PROGRESS_SECONDS", "15")))


def _ansi_palette() -> SimpleNamespace:
    disable = bool(os.environ.get("NO_COLOR")) or not sys.stdout.isatty()
    if disable:
        return SimpleNamespace(
            header="",
            accent="",
            success="",
            warning="",
            error="",
            dim="",
            reset="",
        )
    return SimpleNamespace(
        header="\x1b[95m",
        accent="\x1b[36m",
        success="\x1b[32m",
        warning="\x1b[33m",
        error="\x1b[31m",
        dim="\x1b[2m",
        reset="\x1b[0m",
    )


def _extract_section(lines: List[str], heading: str) -> List[str]:
    target = f"## {heading}".lower()
    start: Optional[int] = None
    for idx, line in enumerate(lines):
        if line.strip().lower() == target:
            start = idx + 1
            break
    if start is None:
        return []
    body: List[str] = []
    for line in lines[start:]:
        if line.strip().startswith("## "):
            break
        body.append(line.rstrip())
    while body and not body[0].strip():
        body.pop(0)
    while body and not body[-1].strip():
        body.pop()
    return body


def _extract_card_metadata(card_path: Path) -> Dict[str, object]:
    metadata: Dict[str, object] = {"title": card_path.stem.replace("-", " ").title()}
    try:
        text = card_path.read_text(encoding="utf-8")
    except OSError:
        return metadata
    lines = text.splitlines()
    for line in lines:
        if line.startswith("# "):
            metadata["title"] = line[2:].strip()
            break
    summary_section = _extract_section(lines, "Summary")
    metadata["summary"] = " ".join(summary_section).strip()
    acceptance_section = _extract_section(lines, "Acceptance Criteria")
    acceptance = [
        item.strip()[2:].strip()
        for item in acceptance_section
        if item.strip().startswith("- ")
    ]
    metadata["acceptance"] = acceptance
    return metadata


def _list_existing_specs(specs_dir: Path) -> List[str]:
    if not specs_dir.exists():
        return []
    items: List[str] = []
    for path in sorted(specs_dir.rglob("*.py")):
        try:
            items.append(str(path.relative_to(specs_dir)))
        except ValueError:
            items.append(path.name)
    return items


def _render_generator_dashboard(
    *,
    card: FeatureCard,
    specs_dir: Path,
    focus: str,
    passes: int,
    options: GeneratorOptions,
) -> None:
    palette = _ansi_palette()
    metadata = _extract_card_metadata(card.path)
    existing_specs = _list_existing_specs(specs_dir)
    header = f"{palette.header}Generator Dashboard{palette.reset}"
    divider = "-" * 62
    print(f"\n{header}")
    print(divider)
    title = metadata.get("title", card.slug)
    summary_text = metadata.get("summary", "")
    acceptance = metadata.get("acceptance") or []
    print(f"{palette.accent}Feature{palette.reset}: {card.slug} ({title})")
    print(f"{palette.accent}Status{palette.reset}: {card.status}")
    if summary_text:
        print(f"{palette.accent}Summary{palette.reset}: {summary_text}")
    if acceptance:
        print(f"{palette.accent}Acceptance Criteria{palette.reset}:")
        for item in acceptance:
            print(f"  - {item}")
    if existing_specs:
        specs_list = ", ".join(existing_specs)
        print(f"{palette.accent}Existing specs{palette.reset}: {specs_list}")
    else:
        print(f"{palette.accent}Existing specs{palette.reset}: (none yet)")
    print(f"{palette.accent}Focus{palette.reset}: {focus or 'default coverage guidance'}")
    print(f"{palette.accent}Pass budget{palette.reset}: {passes} (continuous={options.continuous})")
    print(divider)


def _summarize_diff(diff_text: str) -> Tuple[List[Dict[str, object]], Dict[str, int]]:
    entries: List[Dict[str, object]] = []
    totals = defaultdict(int)
    current: Optional[Dict[str, object]] = None
    for line in diff_text.splitlines():
        if line.startswith("diff --git "):
            if current:
                entries.append(current)
            parts = line.split()
            path = parts[-1] if parts else ""
            if path.startswith("b/"):
                path = path[2:]
            current = {
                "path": path,
                "status": "modified",
                "added": 0,
                "removed": 0,
                "added_tests": [],
                "removed_tests": [],
            }
        elif current is None:
            continue
        elif line.startswith("new file mode"):
            current["status"] = "new"
        elif line.startswith("deleted file mode"):
            current["status"] = "deleted"
        elif line.startswith("+++ b/"):
            if line.endswith("/dev/null"):
                current["status"] = "deleted"
        elif line.startswith("--- a/"):
            if line.endswith("/dev/null"):
                current["status"] = "new"
        elif line.startswith("+") and not line.startswith("+++"):
            current["added"] = current.get("added", 0) + 1
            totals["added_lines"] += 1
            stripped = line[1:].lstrip()
            if stripped.startswith("def test"):
                name = stripped.split("(", 1)[0].replace("def", "", 1).strip()
                current["added_tests"].append(name)
        elif line.startswith("-") and not line.startswith("---"):
            current["removed"] = current.get("removed", 0) + 1
            totals["removed_lines"] += 1
            stripped = line[1:].lstrip()
            if stripped.startswith("def test"):
                name = stripped.split("(", 1)[0].replace("def", "", 1).strip()
                current["removed_tests"].append(name)
    if current:
        entries.append(current)
    totals["files"] = len(entries)
    for entry in entries:
        added_tests = set(entry.get("added_tests", []))
        removed_tests = set(entry.get("removed_tests", []))
        modified_tests = sorted(added_tests & removed_tests)
        entry["modified_tests"] = modified_tests
        entry["added_tests"] = sorted(added_tests - removed_tests)
        entry["removed_tests"] = sorted(removed_tests - added_tests)
    return entries, totals


def _print_diff_summary(diff_text: str) -> None:
    entries, totals = _summarize_diff(diff_text)
    if not entries:
        return
    palette = _ansi_palette()
    files_changed = totals.get("files", 0)
    added_lines = totals.get("added_lines", 0)
    removed_lines = totals.get("removed_lines", 0)
    print(
        f"{palette.accent}Diff summary{palette.reset}: {files_changed} files, "
        f"+{added_lines} / -{removed_lines} lines"
    )
    for entry in entries:
        path = entry["path"]
        status = entry["status"]
        added = entry["added"]
        removed = entry["removed"]
        status_label = status
        if status == "new":
            status_label = f"{palette.success}new{palette.reset}"
        elif status == "deleted":
            status_label = f"{palette.warning}deleted{palette.reset}"
        changes = []
        if added:
            changes.append(f"+{added}")
        if removed:
            changes.append(f"-{removed}")
        change_text = ", ".join(changes) if changes else "no line changes"
        print(f"  • {path} ({status_label}, {change_text})")
        for label, tests in (
            ("added", entry["added_tests"]),
            ("modified", entry["modified_tests"]),
            ("removed", entry["removed_tests"]),
        ):
            if tests:
                joined = ", ".join(tests)
                print(f"      {label} tests: {joined}")


def _emit_codex_updates(chunk: str, palette: SimpleNamespace, last_update: str) -> str:
    lines = [line.strip() for line in chunk.splitlines() if line.strip()]
    if not lines:
        return last_update
    interesting: List[str] = []
    for line in lines:
        if line.startswith(("diff --git", "index ", "--- ", "+++ ", "@@ ", "+", "-", "Applying diff")):
            continue
        if line.startswith("Total patch size"):
            continue
        interesting.append(line)
    candidates = interesting or lines
    for line in candidates[-3:]:
        snippet = line
        if len(snippet) > 160:
            snippet = snippet[:157] + "…"
        if snippet and snippet != last_update:
            print(f"{palette.accent}[generator] Codex: {snippet}{palette.reset}")
            last_update = snippet
    return last_update


def _diagnose_missing_cards(statuses: List[str], context: RexContext) -> None:
    cards = discover_cards(context=context)
    if not cards:
        print("[generator] No Feature Cards found in documents/feature_cards/.")
        return
    palette = _ansi_palette()
    print("[generator] Feature Cards present but none matched the requested statuses.")
    for card in cards:
        suggestion = ""
        for target in statuses:
            if not target:
                continue
            ratio = difflib.SequenceMatcher(None, card.status, target).ratio()
            if ratio >= 0.75 and card.status != target:
                suggestion = (
                    f" ({palette.warning}did you mean \"{target}\"?{palette.reset})"
                )
                break
        status_display = f"status={card.status}"
        print(f"  - {card.slug}: {status_display}{suggestion}")
@dataclass
class GeneratorOptions:
    continuous: bool = True
    max_passes: int = int(os.environ.get("GENERATOR_MAX_PASSES", "5"))
    focus: str = ""
    card_path: Optional[Path] = None
    iterate_all: bool = False
    statuses: List[str] = field(default_factory=lambda: ["proposed"])
    codex_bin: str = os.environ.get("CODEX_BIN", "npx --yes @openai/codex")
    codex_flags: str = os.environ.get("CODEX_FLAGS", "--yolo")
    codex_model: str = os.environ.get("MODEL", "")
    verbose: bool = True
    tail_lines: int = 0


@dataclass
class _CodexResult:
    returncode: int
    stdout: str
    stderr: str
    elapsed_seconds: int


def parse_statuses(raw: str | None) -> List[str]:
    if not raw:
        return ["proposed"]
    tokens = [piece.strip().lower() for piece in raw.split(",") if piece.strip()]
    return tokens or ["proposed"]


def _split_command(raw: str) -> List[str]:
    import shlex

    return shlex.split(raw)


def _run_codex_with_progress(
    cmd: Sequence[str],
    *,
    cwd: Path,
    verbose: bool,
    progress_label: str,
) -> _CodexResult:
    start = time.time()
    process = subprocess.Popen(
        cmd,
        cwd=cwd,
        text=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout_buffer: List[str] = []
    stderr_buffer: List[str] = []
    palette = _ansi_palette()
    last_update = ""
    while True:
        try:
            stdout, stderr = process.communicate(timeout=PROGRESS_INTERVAL_SECONDS)
            if stdout:
                if not isinstance(stdout, str):
                    stdout = stdout.decode()
                stdout_buffer.append(stdout)
                if verbose:
                    last_update = _emit_codex_updates(stdout, palette, last_update)
            if stderr:
                if not isinstance(stderr, str):
                    stderr = stderr.decode()
                stderr_buffer.append(stderr)
            break
        except subprocess.TimeoutExpired as exc:
            # exc.output / exc.stderr contain partial data when text=True and pipes are used
            if exc.output:
                chunk = exc.output if isinstance(exc.output, str) else exc.output.decode()
                stdout_buffer.append(chunk)
                if verbose:
                    last_update = _emit_codex_updates(chunk, palette, last_update)
            if exc.stderr:
                chunk_err = exc.stderr if isinstance(exc.stderr, str) else exc.stderr.decode()
                stderr_buffer.append(chunk_err)
            if verbose:
                elapsed = int(time.time() - start)
                print(f"[generator] {progress_label}… {elapsed}s elapsed", flush=True)
    elapsed_total = int(time.time() - start)
    stdout_combined = "".join(stdout_buffer)
    stderr_combined = "".join(stderr_buffer)
    return _CodexResult(
        returncode=process.returncode or 0,
        stdout=stdout_combined,
        stderr=stderr_combined,
        elapsed_seconds=elapsed_total,
    )


def run_generator(options: GeneratorOptions, *, context: RexContext | None = None) -> int:
    context = context or RexContext.discover()
    self_update()
    ensure_dir(context.codex_ci_dir)
    lock_path = context.codex_ci_dir / "rex_generator.lock"
    with lock_file(lock_path):
        ensure_python(context, quiet=True)
        env_verbose = os.environ.get("GENERATOR_DEBUG")
        if env_verbose is not None:
            options.verbose = env_verbose.lower() not in {"0", "false", ""}
        requirements_template = AGENT_SRC / "templates" / "requirements-dev.txt"
        ensure_requirements_installed(context, requirements_template)
        cards: List[FeatureCard]
        if options.card_path:
            if not options.card_path.exists():
                print(f"[generator] Feature Card not found: {options.card_path}")
                return 1
            slug = options.card_path.stem
            cards = [
                FeatureCard(
                    path=options.card_path,
                    slug=slug,
                    status=options.statuses[0] if options.statuses else "unknown",
                )
            ]
        else:
            cards = discover_cards(statuses=options.statuses, context=context)

        if not cards:
            status_list = ", ".join(options.statuses)
            print(f"[generator] No Feature Cards with statuses: {status_list}")
            if options.statuses:
                _diagnose_missing_cards(options.statuses, context)
            return 1

        if options.iterate_all:
            for card in cards:
                print(f"[generator] === Processing card {card.path} ===")
                if _process_card(card, options, context) != 0:
                    return 1
            return 0

        return _process_card(cards[0], options, context)


def _process_card(card: FeatureCard, options: GeneratorOptions, context: RexContext) -> int:
    slug = card.slug
    status = card.status
    focus = options.focus
    passes = options.max_passes if options.continuous else 1
    specs_dir = context.root / "tests" / "feature_specs" / slug

    update_active_card(context, card=card)
    _render_generator_dashboard(
        card=card,
        specs_dir=specs_dir,
        focus=focus,
        passes=passes,
        options=options,
    )

    for iteration in range(1, passes + 1):
        print(f"[generator] Iteration {iteration}/{passes} (slug: {slug}, status: {status})")
        exit_code, critic_feedback = _run_once(
            card=card,
            slug=slug,
            status=status,
            focus=focus,
            generation_pass=iteration,
            total_passes=passes,
            options=options,
            context=context,
        )
        if exit_code != 0:
            return exit_code

        _run_pytest_snapshot(slug, context)
        critic_ok, critic_focus = _run_critic(
            card=card,
            slug=slug,
            generation_pass=iteration,
            options=options,
            context=context,
        )
        if critic_ok:
            print(f"[generator] Critic returned DONE after pass {iteration}")
            return 0
        if not critic_focus:
            print("[generator] Critic response empty; stopping.")
            return 5
        print("[generator] Critic requested coverage updates:")
        print(critic_focus)
        focus = critic_focus

    print(f"[generator] Hit max passes ({passes}) without critic approval.")
    return 6


def _run_once(
    *,
    card: FeatureCard,
    slug: str,
    status: str,
    focus: str,
    generation_pass: int,
    total_passes: int,
    options: GeneratorOptions,
    context: RexContext,
) -> Tuple[int, Optional[str]]:
    root = context.root
    specs_dir = root / "tests" / "feature_specs" / slug
    specs_dir.mkdir(parents=True, exist_ok=True)

    card_path = root / "documents" / "feature_cards" / f"{slug}.md"
    baseline_card_text: Optional[str] = None
    if card_path.exists():
        try:
            baseline_card_text = card_path.read_text(encoding="utf-8")
        except OSError:
            baseline_card_text = None

    prompt_path = context.codex_ci_dir / "generator_prompt.txt"
    response_path = context.codex_ci_dir / "generator_response.log"
    patch_path = context.codex_ci_dir / "generator_patch.diff"

    prompt = _build_prompt(card, slug, focus, generation_pass, context)
    prompt_path.write_text(prompt, encoding="utf-8")

    cmd = (
        _split_command(options.codex_bin)
        + ["exec"]
        + _split_command(options.codex_flags)
    )
    if options.codex_model:
        cmd += ["--model", options.codex_model]
    cmd += ["--cd", str(root), "--", prompt]

    if options.verbose:
        print("[generator] Calling Codex CLI…")
    completed = _run_codex_with_progress(
        cmd,
        cwd=root,
        verbose=options.verbose,
        progress_label=f"Codex CLI running (pass {generation_pass}/{total_passes})",
    )
    response_path.write_text(
        (completed.stdout or "") + ("\n" if completed.stdout else ""),
        encoding="utf-8",
    )
    if options.verbose:
        print(f"[generator] Codex CLI finished in {completed.elapsed_seconds}s.")
    if completed.returncode != 0:
        stderr = completed.stderr or ""
        response_path.write_text(
            response_path.read_text(encoding="utf-8") + stderr,
            encoding="utf-8",
        )
        print(stderr, file=sys.stderr)
        return 2, None

    diff_text = _extract_diff(response_path, slug)
    patch_path.write_text(diff_text, encoding="utf-8")
    if not diff_text.strip():
        print("[generator] Codex response did not contain a usable diff")
        return 3, None

    if not _enforce_patch_size(diff_text):
        return 3, None

    if not _validate_card_diff(diff_text, slug):
        print("[generator] Codex attempted to modify a protected part of the Feature Card (e.g. the `status:` line).")
        print("[generator] Rejected. Only append inside '## Links' or '## Spec Trace' as documented in AGENTS.md.")
        return 3, None

    if options.verbose:
        print(f"[generator] Codex response saved to {context.relative(response_path)}")
        print(f"[generator] Applying diff from {context.relative(patch_path)}:")
        _print_diff_preview(diff_text)
        _print_diff_summary(diff_text)

    applied, patch_error = _apply_patch(patch_path, root)
    if not applied:
        print("[generator] Failed to apply Codex diff.")
        if patch_error:
            tail = "\n".join(patch_error.splitlines()[-8:])
            print(tail)
        print(f"[generator] Inspect {context.relative(patch_path)} for the diff and {context.relative(response_path)} for raw output.")
        print("[generator] Tip: rerun with `./rex-codex generator --tail 200` to review the Codex response.")
        return 4, None
    if options.verbose:
        print("[generator] Diff applied successfully.")

    if not _guard_card_edits(slug, root, baseline_card_text):
        _revert_generated_files(slug, root)
        return 7, None

    if not _enforce_hermetic_tests(slug, root):
        _revert_generated_files(slug, root)
        return 7, None

    if status == "proposed":
        _update_metadata(card, slug, context)
    print(f"[generator] Specs updated from {card.path}")
    return 0, None


def _build_prompt(card: FeatureCard, slug: str, focus: str, generation_pass: int, context: RexContext) -> str:
    agents_excerpt = (context.root / "AGENTS.md").read_text(encoding="utf-8", errors="ignore")
    card_text = card.path.read_text(encoding="utf-8")
    existing = _append_existing_tests(slug, context)
    prompt = textwrap.dedent(
        f"""\
        You are a senior test architect.
        Produce a *unified git diff* that adds deterministic pytest specs under tests/feature_specs/<feature>/.
        Only touch:
        - tests/feature_specs/<feature>/...
        - documents/feature_cards/<same-card>.md  (to update state/links once tests are created)

        Guardrails:
        - Follow AGENTS.md. Do NOT modify runtime.
        - Tests must import the intended module so first failure is ModuleNotFoundError.
        - Force offline defaults (no network/time.sleep).
        - Include happy-path, env toggle, and explicit error coverage.
        Diff contract: unified diff only (start each file with 'diff --git').
        Determinism:
        - Avoid non-determinism (seed randomness, freeze time, avoid sleeps and network).
        - Prefer explicit assertions and minimal fixtures; ensure failures point to the right module.

        Feature slug: {slug}
        All updates must remain under tests/feature_specs/{slug}/ and the card document.

        --- PASS NUMBER ---
        {generation_pass}
        """
    )
    if focus:
        prompt += "\nAdditional coverage goals from previous critic pass:\n"
        prompt += f"{focus}\n"
    prompt += "\n--- BEGIN AGENTS.md EXCERPT ---\n"
    prompt += agents_excerpt
    prompt += "\n--- END AGENTS.md EXCERPT ---\n\n"
    prompt += "--- BEGIN FEATURE CARD ---\n"
    prompt += card_text
    prompt += "\n--- END FEATURE CARD ---\n"
    prompt += existing
    return prompt


def _append_existing_tests(slug: str, context: RexContext) -> str:
    specs_dir = context.root / "tests" / "feature_specs" / slug
    if not specs_dir.exists():
        return ""
    output = ["\n--- EXISTING TEST FILES ---"]
    for path in sorted(specs_dir.glob("**/*.py")):
        try:
            snippet = path.read_text(encoding="utf-8")
        except OSError:
            continue
        output.append(f"\n### {path}")
        output.append(snippet)
    return "\n".join(output)


def _normalize_unified_diff(diff_text: str) -> str:
    """Normalize line endings and ensure git-apply-friendly trailing newline."""
    normalized = diff_text.replace("\r\n", "\n").replace("\r", "\n")
    if normalized and not normalized.endswith("\n"):
        normalized += "\n"
    return normalized


def _extract_diff(response_path: Path, slug: str) -> str:
    text = response_path.read_text(encoding="utf-8", errors="replace")
    pattern = re.compile(r"^diff --git .*$", re.MULTILINE)
    segments: List[str] = []
    allowed_doc = f"documents/feature_cards/{slug}.md"
    allowed_prefix = f"tests/feature_specs/{slug}/"

    matches = list(pattern.finditer(text))
    for idx, match in enumerate(matches):
        start = match.start()
        end = matches[idx + 1].start() if idx + 1 < len(matches) else len(text)
        block = text[start:end]
        header = block.splitlines()[0]
        header_match = re.match(r"^diff --git a/(.*?) b/(.*?)$", header)
        if not header_match:
            continue
        a_path, b_path = header_match.groups()
        if any(
            candidate.startswith(allowed_prefix) or candidate == allowed_doc
            for candidate in (a_path, b_path)
        ):
            segments.append(block.rstrip("\n"))
    return _normalize_unified_diff("\n\n".join(segments))


def _enforce_patch_size(diff_text: str) -> bool:
    max_files = int(os.environ.get("GENERATOR_MAX_FILES", DEFAULT_GENERATOR_MAX_FILES))
    max_lines = int(os.environ.get("GENERATOR_MAX_LINES", DEFAULT_GENERATOR_MAX_LINES))
    files = 0
    lines = 0
    for line in diff_text.splitlines():
        if line.startswith("diff --git "):
            files += 1
        elif line.startswith(("+", "-")) and not line.startswith(("+++", "---")):
            lines += 1
    if files > max_files or lines > max_lines:
        print(
            f"[generator] diff touches {files} files / {lines} lines "
            f"(limits {max_files}/{max_lines})"
        )
        return False
    return True


def _validate_card_diff(diff_text: str, slug: str) -> bool:
    card_target = f"documents/feature_cards/{slug}.md"
    if card_target not in diff_text:
        return True
    card_pattern = re.compile(rf"^diff --git a/{re.escape(card_target)} b/{re.escape(card_target)}$", re.MULTILINE)
    match = card_pattern.search(diff_text)
    if not match:
        return True
    section = diff_text[match.start():]
    next_diff = section.find("\ndiff --git ")
    if next_diff != -1:
        section = section[:next_diff]
    if re.search(r"^[+-]\s*status\s*:", section, flags=re.IGNORECASE | re.MULTILINE):
        return False
    return True


def _print_diff_preview(diff_text: str) -> None:
    lines = diff_text.splitlines()
    if not lines:
        print("[generator] (no diff content to preview)")
        return
    limit_env = os.environ.get("GENERATOR_DIFF_PREVIEW_LINES")
    try:
        limit = int(limit_env) if limit_env else 200
    except ValueError:
        limit = 200
    preview = lines[:limit]
    for line in preview:
        print(line)
    remaining = len(lines) - len(preview)
    if remaining > 0:
        print(f"[generator] … (diff truncated, {remaining} more lines)")


def _apply_patch(patch_path: Path, root: Path) -> Tuple[bool, Optional[str]]:
    apply_index = run(
        ["git", "apply", "--index", str(patch_path)],
        cwd=root,
        check=False,
        capture_output=True,
    )
    if apply_index.returncode == 0:
        return True, None
    print("[generator] git apply --index failed; retrying without --index")
    apply_wc = run(
        ["git", "apply", str(patch_path)],
        cwd=root,
        check=False,
        capture_output=True,
    )
    if apply_wc.returncode == 0:
        run(["git", "add", "tests", "documents/feature_cards"], cwd=root, check=False)
        return True, None
    combined_error = (apply_wc.stderr or "") + (apply_wc.stdout or "")
    if not combined_error:
        combined_error = (apply_index.stderr or "") + (apply_index.stdout or "")
    return False, combined_error or None


def _guard_card_edits(slug: str, root: Path, baseline_text: Optional[str]) -> bool:
    card_path = root / "documents" / "feature_cards" / f"{slug}.md"
    if not card_path.exists():
        return True

    try:
        after = card_path.read_text(encoding="utf-8")
    except OSError:
        print(f"[generator] Unable to read Feature Card {card_path}")
        return False

    if baseline_text is not None:
        before_text = baseline_text
    else:
        try:
            before_text = run(
                ["git", "show", f"HEAD:{card_path.as_posix()}"],
                capture_output=True,
                check=True,
            ).stdout
        except subprocess.CalledProcessError:
            before_text = ""

    before_lines = before_text.splitlines()
    after_lines = after.splitlines()

    if before_lines == after_lines:
        return True

    allowed_headers = {"## Links", "## Spec Trace"}

    def nearest_header(idx: int) -> Optional[str]:
        for pos in range(idx - 1, -1, -1):
            stripped = after_lines[pos].strip()
            if stripped.startswith("## "):
                return stripped
        return None

    sm = difflib.SequenceMatcher(a=before_lines, b=after_lines)
    for tag, i1, i2, j1, j2 in sm.get_opcodes():
        if tag == "equal":
            continue
        removed = before_lines[i1:i2]
        added = after_lines[j1:j2]
        if any(re.search(r"\bstatus\s*:", line, flags=re.IGNORECASE) for line in removed + added):
            print("[generator] Card edit touches status line; abort.")
            return False
        if tag in {"delete", "replace"}:
            print("[generator] Card edits may only append new lines inside allowed sections.")
            return False
        if tag == "insert":
            header = nearest_header(j1)
            if header is None and added:
                candidate = added[0].strip()
                if candidate.startswith("## "):
                    header = candidate
            if header is None:
                print("[generator] Card edits must appear under an allowed section.")
                return False
            header_key = next(
                (h for h in allowed_headers if header.lower().startswith(h.lower())),
                None,
            )
            if header_key is None:
                print(f"[generator] Card edits under section '{header}' are not permitted.")
                return False
            # Inserted lines are otherwise free-form (links, trace entries, blank lines).
    return True


def _revert_generated_files(slug: str, root: Path) -> None:
    specs_dir = root / "tests" / "feature_specs" / slug
    if specs_dir.exists():
        tracked = run(
            ["git", "ls-files", str(specs_dir)],
            cwd=root,
            capture_output=True,
            check=False,
        ).stdout.splitlines()
        for path in tracked:
            path = path.strip()
            if not path:
                continue
            run(["git", "restore", "--worktree", "--", path], cwd=root, check=False)
        run(["git", "clean", "-fd", "--", str(specs_dir)], cwd=root, check=False)
    card = root / "documents" / "feature_cards" / f"{slug}.md"
    tracked_card = run(
        ["git", "ls-files", "--error-unmatch", str(card)],
        cwd=root,
        capture_output=True,
        check=False,
    )
    if tracked_card.returncode == 0:
        run(["git", "restore", "--staged", "--worktree", "--", str(card)], cwd=root, check=False)
    elif card.exists():
        card.unlink()


def _enforce_hermetic_tests(slug: str, root: Path) -> bool:
    specs_dir = root / "tests" / "feature_specs" / slug
    if not specs_dir.exists():
        return True

    from .hermetic import ensure_hermetic  # Local import to avoid cycles

    return ensure_hermetic(specs_dir)


def _run_pytest_snapshot(slug: str, context: RexContext) -> None:
    specs_dir = context.root / "tests" / "feature_specs" / slug
    log = context.codex_ci_dir / "generator_tests.log"
    if not specs_dir.exists():
        log.write_text(
            f"[generator] No tests/feature_specs/{slug} directory yet; skipping pytest snapshot.\n",
            encoding="utf-8",
        )
        return
    ensure_python(context, quiet=True)
    env = activate_venv(context)
    env["PYTHONHASHSEED"] = env.get("PYTHONHASHSEED", "0")
    timeout_sec = int(os.environ.get("GENERATOR_SNAPSHOT_TIMEOUT", "300"))
    pytest_cmd = ["pytest", str(specs_dir), "-q", "-x", "--maxfail=1"]
    try:
        subprocess.run(
            pytest_cmd,
            cwd=context.root,
            env=env,
            text=True,
            capture_output=True,
            timeout=timeout_sec,
            check=True,
        )
        log.write_text("", encoding="utf-8")
    except subprocess.TimeoutExpired:
        log.write_text(f"[generator] Pytest snapshot timed out after {timeout_sec}s\n", encoding="utf-8")
    except subprocess.CalledProcessError as exc:
        output = (exc.stdout or "") + (exc.stderr or "")
        log.write_text(output, encoding="utf-8")


def _run_critic(
    *,
    card: FeatureCard,
    slug: str,
    generation_pass: int,
    options: GeneratorOptions,
    context: RexContext,
) -> Tuple[bool, str]:
    root = context.root
    prompt_path = context.codex_ci_dir / "generator_critic_prompt.txt"
    response_path = context.codex_ci_dir / "generator_critic_response.log"
    tests_log = context.codex_ci_dir / "generator_tests.log"

    tests_summary = ""
    if tests_log.exists():
        tests_summary = tests_log.read_text(encoding="utf-8", errors="replace")

    card_text = card.path.read_text(encoding="utf-8")
    files_output = []
    specs_dir = root / "tests" / "feature_specs" / slug
    if specs_dir.exists():
        for path in sorted(specs_dir.glob("**/*.py")):
            files_output.append(f"### {path}\n{path.read_text(encoding='utf-8', errors='replace')}")

    discriminator_tail = ""
    latest_log = root / ".codex_ci_latest.log"
    if latest_log.exists():
        lines = latest_log.read_text(encoding="utf-8", errors="replace").splitlines()
        discriminator_tail = "\n".join(lines[-120:])

    prompt_sections = [
        "You are reviewing pytest specs that were just generated for the following Feature Card.",
        "Decide whether the tests fully capture the acceptance criteria and obvious negative cases.",
        "Respond in ONE of two ways:",
        "1. `DONE` (exact uppercase word) if coverage is sufficient.",
        "2. `TODO:` followed by bullet items describing additional scenarios to cover.",
        "Do NOT provide code; only guidance.",
        "",
        "--- GENERATOR PASS ---",
        str(generation_pass),
        "",
        f"Feature slug: {slug}",
        "",
        "--- FEATURE CARD ---",
        card_text,
        "",
        "--- CURRENT TEST FILES ---",
        "\n\n".join(files_output),
        "--- END TEST FILES ---",
    ]
    prompt = "\n".join(prompt_sections)
    if tests_summary:
        prompt += f"\n--- PYTEST OUTPUT (tests/feature_specs/{slug}) ---\n{tests_summary}\n"
    if discriminator_tail:
        prompt += "\n--- MOST RECENT DISCRIMINATOR LOG (tail) ---\n"
        prompt += discriminator_tail + "\n"

    prompt_path.write_text(prompt, encoding="utf-8")

    cmd = (
        _split_command(options.codex_bin)
        + ["exec"]
        + _split_command(options.codex_flags)
    )
    if options.codex_model:
        cmd += ["--model", options.codex_model]
    cmd += ["--cd", str(root), "--", prompt]

    completed = subprocess.run(
        cmd,
        cwd=root,
        capture_output=True,
        text=True,
    )
    response_path.write_text(
        (completed.stdout or "") + ("\n" if completed.stdout else ""),
        encoding="utf-8",
    )
    if completed.returncode != 0:
        if completed.stderr:
            response_path.write_text(
                response_path.read_text(encoding="utf-8") + completed.stderr,
                encoding="utf-8",
            )
        return False, ""

    trimmed = (completed.stdout or "").strip()
    if not trimmed:
        return False, ""
    normalized = re.sub(r"\s+", " ", trimmed.replace("`", "")).strip().upper()
    if normalized == "DONE":
        return True, ""
    return False, trimmed


def _update_metadata(card: FeatureCard, slug: str, context: RexContext) -> None:
    data = load_json(context.rex_agent_file)
    feature = data.setdefault("feature", {})
    feature["active_card"] = str(card.relative_path)
    feature["active_slug"] = slug
    feature["updated_at"] = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    dump_json(context.rex_agent_file, data)

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/hermetic.py ===
"""Hermeticity enforcement for generated specs."""

from __future__ import annotations

import ast
from pathlib import Path
from typing import Iterable, List, Tuple


BANNED_IMPORT_MODULES = {
    "requests": "network access via requests",
    "httpx": "network access via httpx",
    "urllib": "network access via urllib",
    "urllib3": "network access via urllib3",
    "aiohttp": "network access via aiohttp",
    "socket": "network access via socket",
    "secrets": "secrets module is non-deterministic; inject fixed values instead",
}

BANNED_CALL_PREFIXES = {
    "requests.": "network access via requests",
    "httpx.": "network access via httpx",
    "urllib.": "network access via urllib",
    "urllib3.": "network access via urllib3",
    "aiohttp.": "network access via aiohttp",
    "socket.": "network access via socket",
    "secrets.": "secrets module is non-deterministic; inject fixed values instead",
    "numpy.random.": "numpy.random must be seeded deterministically; avoid direct usage",
    "random.SystemRandom.": "SystemRandom uses system entropy; avoid in specs",
}

BANNED_CALL_EXACT = {
    "time.sleep": "time.sleep introduces nondeterministic delays",
    "asyncio.sleep": "asyncio.sleep introduces nondeterministic delays",
    "subprocess.run": "subprocess usage requires explicit stubbing",
    "subprocess.Popen": "subprocess usage requires explicit stubbing",
    "subprocess.call": "subprocess usage requires explicit stubbing",
    "os.system": "os.system usage should be avoided in specs",
    "time.time": "use a deterministic clock stub instead of time.time",
    "time.perf_counter": "use a deterministic clock stub instead of time.perf_counter",
    "time.monotonic": "use a deterministic clock stub instead of time.monotonic",
    "datetime.datetime.now": "use a frozen datetime or dependency injection",
    "datetime.datetime.utcnow": "use a frozen datetime or dependency injection",
    "datetime.datetime.today": "use a frozen datetime or dependency injection",
    "datetime.date.today": "use a frozen date or dependency injection",
    "pytest.skip": "skipping generated specs is not allowed",
    "pytest.xfail": "xfailing generated specs is not allowed",
    "os.urandom": "use deterministic stubs instead of os.urandom",
    "uuid.uuid4": "use a fixed UUID in specs instead of uuid.uuid4",
    "uuid.uuid1": "use a fixed UUID in specs instead of uuid.uuid1",
}

RANDOM_PREFIXES = ("random.", "numpy.random.")
RANDOM_ALLOWED = {"random.seed", "numpy.random.seed"}


class HermeticVisitor(ast.NodeVisitor):
    def __init__(self, path: Path) -> None:
        self.path = path
        self.aliases: dict[str, str] = {}
        self.violations: List[Tuple[Path, int, str]] = []

    def add_violation(self, lineno: int, detail: str) -> None:
        self.violations.append((self.path, lineno, detail))

    def visit_Import(self, node: ast.Import) -> None:
        for alias in node.names:
            name = alias.asname or alias.name.split(".")[-1]
            self.aliases[name] = alias.name
            root = alias.name.split(".")[0]
            if root in BANNED_IMPORT_MODULES:
                self.add_violation(node.lineno, f"import {alias.name} ({BANNED_IMPORT_MODULES[root]})")
        self.generic_visit(node)

    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        module = node.module or ""
        root = module.split(".")[0] if module else ""
        if root in BANNED_IMPORT_MODULES:
            self.add_violation(node.lineno, f"from {module} import ... ({BANNED_IMPORT_MODULES[root]})")
        for alias in node.names:
            target = f"{module}.{alias.name}" if module else alias.name
            name = alias.asname or alias.name
            self.aliases[name] = target
        self.generic_visit(node)

    def resolve(self, node: ast.AST) -> str | None:
        if isinstance(node, ast.Name):
            return self.aliases.get(node.id, node.id)
        if isinstance(node, ast.Attribute):
            base = self.resolve(node.value)
            if base:
                return f"{base}.{node.attr}"
            return node.attr
        return None

    def visit_Call(self, node: ast.Call) -> None:
        call_name = self.resolve(node.func)
        if call_name:
            if call_name in BANNED_CALL_EXACT:
                self.add_violation(node.lineno, f"{call_name} ({BANNED_CALL_EXACT[call_name]})")
            elif (
                any(call_name.startswith(prefix) for prefix in RANDOM_PREFIXES)
                and call_name not in RANDOM_ALLOWED
            ):
                self.add_violation(node.lineno, f"{call_name} (set a deterministic seed or avoid randomness)")
            else:
                for prefix, reason in BANNED_CALL_PREFIXES.items():
                    if call_name.startswith(prefix):
                        self.add_violation(node.lineno, f"{call_name} ({reason})")
                        break
        self.generic_visit(node)

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        for dec in node.decorator_list:
            name = self.resolve(dec)
            if not name:
                continue
            lname = name.lower()
            if lname.startswith("pytest.mark.skip") or lname.startswith("pytest.mark.xfail"):
                self.add_violation(
                    getattr(dec, "lineno", node.lineno),
                    f"{name} (skipping/xfailing specs is forbidden)",
                )
            elif lname.startswith("pytest.mark.skipif"):
                args = getattr(dec, "args", [])
                if args:
                    first = args[0]
                    value = getattr(first, "value", None)
                    if value is True:
                        self.add_violation(
                            getattr(dec, "lineno", node.lineno),
                            "pytest.mark.skipif(True, ...) is forbidden",
                        )
        self.generic_visit(node)


def ensure_hermetic(specs_dir: Path) -> bool:
    violations: List[Tuple[Path, int, str]] = []
    for path in specs_dir.rglob("*.py"):
        try:
            tree = ast.parse(path.read_text(encoding="utf-8"))
        except SyntaxError as err:
            violations.append((path, err.lineno or 0, f"SyntaxError: {err}"))
            continue
        visitor = HermeticVisitor(path)
        visitor.visit(tree)
        violations.extend(visitor.violations)

    if violations:
        for path, lineno, detail in violations:
            location = f"{path}:{lineno}" if lineno else str(path)
            print(f"{location}: {detail}")
        return False
    return True

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/init.py ===
"""Project initialisation for rex-codex."""

from __future__ import annotations

import json
import shutil
from pathlib import Path

from . import __version__
from .config import AGENT_SRC
from .self_update import self_update
from .utils import (
    RexContext,
    dump_json,
    ensure_dir,
    ensure_python,
    ensure_requirements_installed,
    repo_root,
)


def _copy_if_missing(src: Path, dest: Path) -> None:
    if dest.exists():
        return
    dest.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dest)


def run_init(*, context: RexContext | None = None, perform_self_update: bool = True) -> None:
    context = context or RexContext.discover()
    if perform_self_update:
        self_update()

    print("[*] Bootstrapping Python environment…")
    ensure_python(context)

    requirements_template = AGENT_SRC / "templates" / "requirements-dev.txt"
    ensure_requirements_installed(context, requirements_template, quiet=False)

    root = context.root
    ensure_dir(root / "tests" / "enforcement")
    ensure_dir(root / "documents" / "feature_cards")

    template_root = AGENT_SRC / "templates"
    copies = {
        "AGENTS.md": root / "AGENTS.md",
        "pytest.ini": root / "pytest.ini",
        "pyproject.toml": root / "pyproject.toml",
        "mypy.ini": root / "mypy.ini",
        "conftest.py": root / "conftest.py",
        ".flake8": root / ".flake8",
    }
    for rel, dest in copies.items():
        src = template_root / rel
        if src.exists():
            _copy_if_missing(src, dest)

    card_readme = template_root / "documents" / "feature_cards" / "README.md"
    if card_readme.exists():
        _copy_if_missing(card_readme, root / "documents" / "feature_cards" / "README.md")

    enforcement_dir = template_root / "tests" / "enforcement"
    if enforcement_dir.exists():
        for item in enforcement_dir.glob("**/*"):
            if item.is_file():
                rel = item.relative_to(enforcement_dir)
                dest = root / "tests" / "enforcement" / rel
                _copy_if_missing(item, dest)

    agent_state = {
        "stages": [
            "sanity",
            "deps",
            "specs",
            "unit",
            "style",
        ],
        "llm": {"bin": "npx --yes @openai/codex", "flags": "--yolo", "model": ""},
        "feature": {
            "active_card": None,
            "active_slug": None,
            "updated_at": None,
        },
        "version": __version__,
    }
    dump_json(context.rex_agent_file, agent_state)
    print("[✓] Project initialized. Try: ./rex-codex loop")

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/install.py ===
"""Install or re-install the rex-codex agent."""

from __future__ import annotations

import os
import subprocess
from pathlib import Path

from .config import AGENT_SRC
from .doctor import run_doctor
from .init import run_init
from .utils import RexContext, RexError


def run_install(
    *,
    force: bool = False,
    channel: str | None = None,
    run_init_after: bool = True,
    run_doctor_after: bool = True,
    context: RexContext | None = None,
) -> None:
    """Invoke the bundled install script to (re)install the agent."""
    context = context or RexContext.discover()
    script = AGENT_SRC / "scripts" / "install.sh"
    if not script.exists():
        raise RexError(f"Install script not found: {script}")

    cmd = ["bash", str(script)]
    if force:
        cmd.append("--force")
    if channel:
        cmd.extend(["--channel", channel])

    env = os.environ.copy()
    if channel:
        env["REX_AGENT_CHANNEL"] = channel
    env["REX_AGENT_SKIP_INIT"] = "1"
    env["REX_AGENT_SKIP_DOCTOR"] = "1"
    completed = subprocess.run(cmd, cwd=context.root, env=env)
    if completed.returncode != 0:
        raise RexError(f"Install command failed with exit code {completed.returncode}")

    if run_init_after:
        run_init(context=context, perform_self_update=False)
    if run_doctor_after:
        run_doctor()

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/logs.py ===
"""Log helpers for rex-codex."""

from __future__ import annotations

from pathlib import Path
from .utils import RexContext


def tail_log(path: Path, *, lines: int = 120) -> None:
    if not path.exists():
        print(f"[logs] {path} not found.")
        return
    content = path.read_text(encoding="utf-8", errors="replace").splitlines()
    start = max(0, len(content) - lines)
    for line in content[start:]:
        print(line)


def show_latest_logs(
    context: RexContext,
    *,
    lines: int = 120,
    generator: bool = False,
    discriminator: bool = False,
) -> None:
    sections: list[tuple[str, Path]] = []

    include_generator = generator or not (generator or discriminator)
    include_discriminator = discriminator or not (generator or discriminator)

    if include_generator:
        sections.extend(
            [
                ("Generator response", context.codex_ci_dir / "generator_response.log"),
                ("Generator patch", context.codex_ci_dir / "generator_patch.diff"),
                ("Generator tests", context.codex_ci_dir / "generator_tests.log"),
            ]
        )
    if include_discriminator:
        sections.extend(
            [
                ("Discriminator log", context.codex_ci_dir / "latest_discriminator.log"),
                ("Discriminator latest", context.root / ".codex_ci_latest.log"),
            ]
        )

    seen: set[Path] = set()
    for label, path in sections:
        if path in seen:
            continue
        seen.add(path)
        if path.exists():
            print(f"--- {label}: {context.relative(path)} (last {lines} lines) ---")
            tail_log(path, lines=lines)
        else:
            print(f"[logs] Missing {label.lower()} at {context.relative(path)}")

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/loop.py ===
"""Generator → discriminator orchestration."""

from __future__ import annotations

import os
import sys
from dataclasses import dataclass, field, replace
from types import SimpleNamespace
from typing import List

from .cards import discover_cards, load_rex_agent
from .discriminator import DiscriminatorOptions, run_discriminator
from .doctor import run_doctor
from .generator import GeneratorOptions, run_generator
from .logs import show_latest_logs
from .self_update import self_update
from .utils import RexContext, lock_file, create_audit_snapshot


GENERATOR_EXIT_MESSAGES = {
    0: "Specs updated",
    1: "No matching Feature Cards",
    2: "Codex CLI error (see generator logs)",
    3: "Diff rejected by guardrail",
    4: "Diff failed to apply cleanly",
    5: "Critic returned empty guidance",
    6: "Max passes reached without DONE",
    7: "Guardrail rejection (card edit or hermetic failure)",
}

DISCRIMINATOR_EXIT_MESSAGES = {
    0: "Ladder passed",
    1: "Stage failure (see summary above)",
    2: "LLM disabled or patch rejected",
}


def _ansi_palette() -> SimpleNamespace:
    disable = bool(os.environ.get("NO_COLOR")) or not sys.stdout.isatty()
    if disable:
        return SimpleNamespace(
            success="",
            warning="",
            error="",
            label="",
            dim="",
            reset="",
        )
    return SimpleNamespace(
        success="\x1b[32m",
        warning="\x1b[33m",
        error="\x1b[31m",
        label="\x1b[36m",
        dim="\x1b[2m",
        reset="\x1b[0m",
    )


def _describe_generator_exit(code: int | None) -> tuple[str, str]:
    if code is None:
        return "skipped", "Skipped (flagged off)"
    message = GENERATOR_EXIT_MESSAGES.get(code, "Unknown generator exit")
    if code == 0:
        return "pass", message
    if code in (1, 2):
        return "warn", message
    return "fail", message


def _describe_discriminator_exit(code: int | None) -> tuple[str, str]:
    if code is None:
        return "skipped", "Skipped (flagged off)"
    message = DISCRIMINATOR_EXIT_MESSAGES.get(code, "Unknown discriminator exit")
    if code == 0:
        return "pass", message
    return "fail", message


def _render_loop_summary(
    *,
    generator_code: int | None,
    discriminator_code: int | None,
) -> None:
    palette = _ansi_palette()
    gen_state, gen_message = _describe_generator_exit(generator_code)
    disc_state, disc_message = _describe_discriminator_exit(discriminator_code)
    def _format(state: str, label: str) -> str:
        if state == "pass":
            color = palette.success
        elif state == "warn":
            color = palette.warning
        elif state == "fail":
            color = palette.error
        else:
            color = palette.dim
        return f"{color}{label}{palette.reset}"

    print("\n=== Loop Summary =============================================")
    print(f"{palette.label}Generator{palette.reset}: {_format(gen_state, gen_state.upper())} — {gen_message}")
    print(f"{palette.label}Discriminator{palette.reset}: {_format(disc_state, disc_state.upper())} — {disc_message}")
    print("==============================================================")


def _perform_audit(context: RexContext) -> None:
    try:
        create_audit_snapshot(context)
    except Exception as exc:  # pragma: no cover - filesystem/git errors
        print(f"[loop] Audit snapshot failed: {exc}")


@dataclass
class LoopOptions:
    generator_options: GeneratorOptions = field(default_factory=GeneratorOptions)
    discriminator_options: DiscriminatorOptions = field(default_factory=DiscriminatorOptions)
    run_generator: bool = True
    run_discriminator: bool = True
    run_feature: bool = True
    run_global: bool = True
    each_features: bool = False
    perform_self_update: bool = True
    explain: bool = False
    verbose: bool = True
    tail_lines: int = 0


def run_loop(options: LoopOptions, *, context: RexContext | None = None) -> int:
    context = context or RexContext.discover()
    if options.explain:
        for line in _describe_plan(options, context):
            print(line)
    if options.perform_self_update:
        self_update()
    options.generator_options.verbose = options.verbose
    options.discriminator_options.verbose = options.verbose
    lock_path = context.codex_ci_dir / "rex.lock"
    with lock_file(lock_path):
        run_doctor()
        if options.each_features:
            return _run_each(options, context)
        return _run_single(options, context)


def _describe_plan(options: LoopOptions, context: RexContext) -> List[str]:
    lines: List[str] = []
    statuses = options.generator_options.statuses or ["proposed"]
    lines.append(
        f"Self-update: {'enabled' if options.perform_self_update else 'disabled'} "
        "(honours REX_AGENT_NO_UPDATE)"
    )
    lines.append(f"Generator phase: {'enabled' if options.run_generator else 'skipped'}")
    if options.run_generator:
        if options.generator_options.card_path:
            target = str(options.generator_options.card_path)
        else:
            target = ", ".join(statuses)
        lines.append(f"  target: {target}")
        lines.append(f"  iterate-each: {'yes' if options.each_features else 'no'}")
    lines.append(f"Discriminator phase: {'enabled' if options.run_discriminator else 'skipped'}")
    if options.run_discriminator:
        lines.append(f"  feature shard: {'yes' if options.run_feature else 'no'}")
        lines.append(f"  global sweep: {'yes' if options.run_global else 'no'}")
        lines.append(
            f"  LLM runtime edits: "
            f"{'disabled' if options.discriminator_options.disable_llm else 'enabled'}"
        )
    if options.each_features and options.run_generator:
        cards = discover_cards(statuses=options.generator_options.statuses, context=context)
        if cards:
            preview = ", ".join(card.slug for card in cards[:5])
            if len(cards) > 5:
                preview += f", … (+{len(cards) - 5} more)"
            lines.append(f"  queued cards: {preview}")
        else:
            lines.append("  queued cards: none")
    return lines


def _run_each(options: LoopOptions, context: RexContext) -> int:
    cards = discover_cards(statuses=options.generator_options.statuses, context=context)
    if not cards:
        statuses = ", ".join(options.generator_options.statuses)
        print(f"[loop] No Feature Cards with statuses: {statuses}")
        return 1
    for card in cards:
        print(f"=== rex-codex loop: processing {card.path} (slug: {card.slug}) ===")
        if options.run_generator:
            generator_opts = replace(options.generator_options, card_path=card.path)
            result = run_generator(generator_opts, context=context)
            if result != 0:
                _maybe_tail_logs("generator", options.tail_lines, context)
                print(f"[loop] Generator failed on {card.path} (exit {result})")
                _perform_audit(context)
                return result
            if options.verbose:
                _announce_log(context, "generator_response.log")
        else:
            print("[loop] Generator skipped.")
        if options.run_discriminator:
            exit_code = _run_discriminator_phases(options, card.slug, context)
            if exit_code != 0:
                _perform_audit(context)
                return exit_code
    _perform_audit(context)
    return 0


def _run_single(options: LoopOptions, context: RexContext) -> int:
    generator_code: int | None = None
    if options.run_generator:
        print("=== rex-codex loop: generator phase ===")
        generator_code = run_generator(options.generator_options, context=context)
        if generator_code == 0:
            print("[loop] Generator produced new specs; running discriminator…")
            if options.verbose:
                _announce_log(context, "generator_response.log")
        elif generator_code == 1:
            print("[loop] Generator found no matching Feature Cards; running discriminator anyway.")
        else:
            print(f"[loop] Generator failed (exit {generator_code}); aborting.")
            _maybe_tail_logs("generator", options.tail_lines, context)
            _render_loop_summary(generator_code=generator_code, discriminator_code=None)
            _perform_audit(context)
            return generator_code
    else:
        print("[loop] Generator skipped; running discriminator only.")
        generator_code = None

    discriminator_code: int | None = None
    exit_code = 0
    if options.run_discriminator:
        slug = _discover_active_slug(context)
        print("=== rex-codex loop: discriminator phase ===")
        discriminator_code = _run_discriminator_phases(options, slug, context)
        exit_code = discriminator_code
        if discriminator_code == 0 and options.verbose:
            _announce_log(context, "latest_discriminator.log")
    else:
        print("[loop] Discriminator skipped; generator phase complete.")
        exit_code = generator_code if generator_code not in (None, 0, 1) else 0

    _render_loop_summary(generator_code=generator_code, discriminator_code=discriminator_code)
    _perform_audit(context)
    return exit_code


def _run_discriminator_phases(options: LoopOptions, slug: str | None, context: RexContext) -> int:
    if options.run_feature:
        if slug:
            feature_opts = replace(options.discriminator_options, mode="feature", slug=slug)
            result = run_discriminator(feature_opts, context=context)
            if result != 0:
                _maybe_tail_logs("discriminator", options.tail_lines, context)
                return result
        else:
            print("[loop] No active feature slug; skipping feature-only discriminator run.")
    if options.run_global:
        global_opts = replace(options.discriminator_options, mode="global", slug=None)
        result = run_discriminator(global_opts, context=context)
        if result != 0:
            _maybe_tail_logs("discriminator", options.tail_lines, context)
        return result
    print("[loop] Global discriminator run skipped by flag.")
    return 0


def _discover_active_slug(context: RexContext) -> str | None:
    data = load_rex_agent(context)
    feature = data.get("feature", {})
    slug = feature.get("active_slug")
    if slug:
        return slug
    cards = discover_cards(statuses=["proposed"], context=context)
    return cards[0].slug if cards else None


def _maybe_tail_logs(kind: str, lines: int, context: RexContext) -> None:
    if lines <= 0:
        return
    if kind == "generator":
        show_latest_logs(context, lines=lines, generator=True)
    elif kind == "discriminator":
        show_latest_logs(context, lines=lines, discriminator=True)


def _announce_log(context: RexContext, filename: str) -> None:
    path = context.codex_ci_dir / filename
    if path.exists():
        print(f"[loop] Logs: {context.relative(path)}")

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/self_update.py ===
"""Agent self-update helpers."""

from __future__ import annotations

import os
from pathlib import Path

from .config import AGENT_SRC
from .utils import RexError, run


def self_update(channel: str | None = None) -> None:
    """Mirror the legacy Bash self-update strategy."""
    if os.environ.get("REX_AGENT_NO_UPDATE", "1") == "1" and channel is None:
        return

    src = AGENT_SRC
    if not (src / ".git").exists():
        # Nothing to update; installation likely incomplete.
        return

    run(["git", "-C", str(src), "fetch", "--all", "--tags", "--prune", "--force"], check=False)

    channel = channel or os.environ.get("REX_AGENT_CHANNEL", "stable")
    if channel == "stable":
        completed = run(
            ["git", "-C", str(src), "tag", "--sort=-v:refname"],
            capture_output=True,
            check=False,
        )
        tags = [line.strip() for line in completed.stdout.splitlines() if line.strip()]
        target = tags[0] if tags else "main"
        run(["git", "-C", str(src), "checkout", "-q", target], check=False)
    elif channel == "main":
        run(["git", "-C", str(src), "checkout", "-q", "main"], check=False)
        run(["git", "-C", str(src), "pull", "--ff-only"], check=False)
    else:
        run(["git", "-C", str(src), "checkout", "-q", channel], check=False)


=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/status.py ===
"""Helpers to surface rex-agent.json metadata."""

from __future__ import annotations

import datetime as dt
from pathlib import Path
from typing import Any, Dict, Iterable

from .cards import FeatureCard, discover_cards, load_rex_agent
from .utils import RexContext


def _format_timestamp(value: str | None) -> str:
    if not value:
        return "unknown"
    try:
        normalized = value[:-1] + "+00:00" if value.endswith("Z") else value
        when = dt.datetime.fromisoformat(normalized)
    except ValueError:
        return value
    return when.isoformat(timespec="seconds")


def summarize_context(context: RexContext) -> Dict[str, Any]:
    data = load_rex_agent(context)
    feature = data.get("feature", {})
    active_slug = feature.get("active_slug")
    active_card_path = feature.get("active_card")
    active_card: FeatureCard | None = None

    if active_card_path:
        path = (context.root / active_card_path).resolve()
        if path.exists():
            active_card = FeatureCard(path=path, slug=active_slug or path.stem, status="")
    else:
        cards = discover_cards(context=context, statuses=["proposed"])
        active_card = cards[0] if cards else None

    return {
        "active_slug": active_slug or (active_card.slug if active_card else None),
        "active_card": active_card_path or (str(active_card.relative_path) if active_card else None),
        "stages": data.get("stages"),
        "llm": data.get("llm"),
        "feature": {
            "active_card": active_card_path,
            "active_slug": active_slug,
            "updated_at": _format_timestamp(feature.get("updated_at")),
        },
    }


def render_status(context: RexContext) -> None:
    summary = summarize_context(context)
    print("Active Feature:")
    print(f"  slug: {summary.get('active_slug') or 'none'}")
    print(f"  card: {summary.get('active_card') or 'none'}")
    feature = summary.get("feature", {})
    print(f"  updated_at: {feature.get('updated_at')}")
    stages = summary.get("stages")
    if isinstance(stages, Iterable):
        print("Configured Stages:")
        for stage in stages:
            print(f"  - {stage}")
    llm = summary.get("llm")
    if isinstance(llm, dict):
        print("LLM Settings:")
        for key, value in llm.items():
            print(f"  {key}: {value}")

=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/uninstall.py ===
"""Implementation of `rex-codex uninstall`."""

from __future__ import annotations

import shutil
from pathlib import Path

from .utils import RexContext, ask_confirmation


def uninstall_agent(*, force: bool, keep_wrapper: bool, context: RexContext | None = None) -> None:
    context = context or RexContext.discover()
    root = context.root
    agent_dir = root / ".rex_agent"
    wrapper = root / "rex-codex"

    if not force:
        print("This will remove the Codex agent from:")
        print(f"  - {agent_dir}")
        if keep_wrapper:
            print("  - (wrapper preserved due to --keep-wrapper)")
        else:
            print(f"  - {wrapper}")
        if not ask_confirmation("Type 'remove agent' to continue: ", expected="remove agent"):
            print("[uninstall] Aborted.")
            return

    if agent_dir.exists():
        shutil.rmtree(agent_dir)
        print(f"[uninstall] Removed {agent_dir}")
    else:
        print("[uninstall] No .rex_agent directory found; nothing to remove.")

    if not keep_wrapper and wrapper.exists():
        wrapper.unlink()
        print(f"[uninstall] Removed {wrapper}")

    print("[uninstall] Agent uninstalled. Remove guardrail artefacts manually if desired.")


=== /media/skynet3/8tb_a1/rex_codex_agent/rex_codex/utils.py ===
"""Shared utilities for the rex-codex Python CLI."""

from __future__ import annotations

import json
import os
import shlex
import subprocess
import sys
from datetime import UTC, datetime
from contextlib import contextmanager
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, Iterator, List, Mapping, MutableMapping, Optional, Sequence, Set


class RexError(RuntimeError):
    """Raised when a command should exit with a non-zero status."""


def _env_root() -> Optional[Path]:
    root = os.environ.get("ROOT")
    if root:
        return Path(root).resolve()
    return None


def repo_root() -> Path:
    """Return the repository root, favouring the git toplevel."""
    if cached := _env_root():
        return cached
    try:
        completed = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
        )
        return Path(completed.stdout.strip()).resolve()
    except subprocess.CalledProcessError:
        return Path.cwd().resolve()


def agent_home(root: Path | None = None) -> Path:
    root = root or repo_root()
    return root / ".rex_agent"


def agent_src(root: Path | None = None) -> Path:
    root = root or repo_root()
    env_src = os.environ.get("REX_SRC")
    if env_src:
        return Path(env_src).resolve()
    return agent_home(root) / "src"


def ensure_dir(path: Path) -> Path:
    path.mkdir(parents=True, exist_ok=True)
    return path


def load_json(path: Path) -> dict:
    if not path.exists():
        return {}
    return json.loads(path.read_text(encoding="utf-8"))


def dump_json(path: Path, data: Mapping) -> None:
    text = json.dumps(data, indent=2, sort_keys=True)
    path.write_text(f"{text}\n", encoding="utf-8")


def which(executable: str) -> Optional[str]:
    from shutil import which as _which

    return _which(executable)


def shlex_join(cmd: Sequence[str]) -> str:
    return shlex.join(cmd)


def run(
    cmd: Sequence[str],
    *,
    cwd: Path | None = None,
    env: Mapping[str, str] | None = None,
    check: bool = True,
    capture_output: bool = False,
    text: bool = True,
) -> subprocess.CompletedProcess:
    """Thin wrapper around subprocess.run with sensible defaults."""
    merged_env: MutableMapping[str, str]
    if env is None:
        merged_env = os.environ.copy()
    else:
        merged_env = {**os.environ, **env}
    kwargs: Dict[str, object] = {"cwd": cwd, "env": merged_env, "check": check}
    if capture_output:
        kwargs["stdout"] = subprocess.PIPE
        kwargs["stderr"] = subprocess.PIPE
    if text:
        kwargs["text"] = True
    return subprocess.run(list(cmd), **kwargs)  # type: ignore[arg-type]


@dataclass(frozen=True)
class RexContext:
    root: Path
    codex_ci_dir: Path
    rex_agent_file: Path
    venv_dir: Path

    @classmethod
    def discover(cls) -> "RexContext":
        root = repo_root()
        codex_ci = ensure_dir(root / ".codex_ci")
        return cls(
            root=root,
            codex_ci_dir=codex_ci,
            rex_agent_file=root / "rex-agent.json",
            venv_dir=root / ".venv",
        )

    def relative(self, path: Path) -> str:
        try:
            return str(path.relative_to(self.root))
        except ValueError:
            return str(path)


class FileLock:
    """Simple advisory file lock using fcntl."""

    def __init__(self, lock_path: Path):
        self.lock_path = lock_path
        self._fd: Optional[int] = None

    def acquire(self, blocking: bool = False) -> None:
        import fcntl

        fd = os.open(self.lock_path, os.O_RDWR | os.O_CREAT, 0o666)
        flag = fcntl.LOCK_EX
        if not blocking:
            flag |= fcntl.LOCK_NB
        try:
            fcntl.flock(fd, flag)
        except BlockingIOError as exc:  # pragma: no cover - depends on runtime race
            os.close(fd)
            raise RexError(f"Another rex-codex process holds {self.lock_path}") from exc
        self._fd = fd

    def release(self) -> None:
        import fcntl

        if self._fd is None:
            return
        try:
            fcntl.flock(self._fd, fcntl.LOCK_UN)
        finally:
            os.close(self._fd)
            self._fd = None

    def __enter__(self) -> "FileLock":
        self.acquire()
        return self

    def __exit__(self, exc_type, exc, tb) -> None:
        self.release()


@contextmanager
def lock_file(path: Path) -> Iterator[None]:
    lock = FileLock(path)
    lock.acquire()
    try:
        yield
    finally:
        lock.release()


def ensure_python(context: RexContext, *, quiet: bool = False) -> None:
    if which("python3") is None:
        raise RexError("python3 not found on PATH")
    if not context.venv_dir.exists():
        if not quiet:
            print("[*] Creating Python virtual environment (.venv)…")
        run(["python3", "-m", "venv", str(context.venv_dir)])
    pip = context.venv_dir / "bin" / "pip"
    run([str(pip), "install", "--upgrade", "pip"], check=True)


def activate_venv(context: RexContext) -> Dict[str, str]:
    env = os.environ.copy()
    env["VIRTUAL_ENV"] = str(context.venv_dir)
    bin_path = context.venv_dir / "bin"
    current_path = env.get("PATH", "")
    env["PATH"] = f"{bin_path}{os.pathsep}{current_path}"
    return env


def read_lines(path: Path) -> List[str]:
    if not path.exists():
        return []
    return [line.rstrip("\n") for line in path.read_text(encoding="utf-8").splitlines()]


def write_text(path: Path, text: str) -> None:
    path.write_text(text, encoding="utf-8")


def print_header(title: str) -> None:
    print(f"=== {title} ===")


def prompt(message: str) -> str:
    try:
        return input(message)
    except EOFError:
        return ""


def ask_confirmation(message: str, *, expected: str) -> bool:
    response = prompt(message)
    return response.strip() == expected


def ensure_requirements_installed(
    context: RexContext,
    requirements_template: Path,
    *,
    quiet: bool = True,
) -> None:
    env = activate_venv(context)
    pip = context.venv_dir / "bin" / "pip"
    base_cmd: List[str] = [str(pip), "install"]
    if quiet:
        base_cmd.append("-q")
    if requirements_template.exists():
        run(base_cmd + ["-r", str(requirements_template)], env=env)
    else:
        baseline = [
            "pytest==8.0.2",
            "pytest-xdist==3.5.0",
            "pytest-cov==4.1.0",
            "black==24.4.2",
            "isort==5.13.2",
            "ruff==0.3.2",
            "flake8==7.0.0",
            "mypy==1.8.0",
        ]
        run(base_cmd + baseline, env=env)


def _audit_candidate_paths(root: Path) -> List[Path]:
    patterns = [
        "*.md",
        "AGENTS.md",
        "README.md",
        "documents/**/*.md",
        "bin/**/*.py",
        "bin/**/*.sh",
        "scripts/**/*.py",
        "scripts/**/*.sh",
        "rex_codex/**/*.py",
    ]
    seen: Set[Path] = set()
    excluded_root = root / "for_external_GPT5_pro_audit"
    for pattern in patterns:
        for path in root.glob(pattern):
            if not path.is_file():
                continue
            if excluded_root in path.parents:
                continue
            seen.add(path.resolve())
    return sorted(seen)


def _is_gitignored(root: Path, path: Path) -> bool:
    try:
        relative = path.relative_to(root)
    except ValueError:
        return False
    try:
        result = run(
            ["git", "check-ignore", "-q", "--", str(relative)],
            cwd=root,
            capture_output=True,
            check=False,
        )
    except FileNotFoundError:
        return False
    return result.returncode == 0


def _render_directory_listing(root: Path) -> str:
    max_depth = 3
    per_dir_limit = 25
    line_budget = 400
    skip_dir_names = {"__pycache__", ".pytest_cache", ".mypy_cache", ".ruff_cache", ".nox", ".idea"}
    skip_contents_dirs = {".git"}
    gitignore_cache: Dict[Path, bool] = {}
    lines: List[str] = []
    truncated = False

    def add_line(text: str) -> bool:
        nonlocal line_budget, truncated
        if truncated:
            return False
        if line_budget <= 0:
            lines.append("  ... (directory listing truncated)")
            truncated = True
            return False
        lines.append(text)
        line_budget -= 1
        return True

    def is_gitignored_cached(path: Path) -> bool:
        resolved = path.resolve()
        if resolved in gitignore_cache:
            return gitignore_cache[resolved]
        ignored = _is_gitignored(root, resolved)
        gitignore_cache[resolved] = ignored
        return ignored

    def walk(path: Path, depth: int) -> None:
        nonlocal truncated
        if truncated:
            return
        try:
            entries = sorted(
                path.iterdir(),
                key=lambda item: (not item.is_dir(), item.name.lower()),
            )
        except OSError as exc:
            add_line(f"{'  ' * (depth + 1)}[Error listing {path.name}: {exc}]")
            return

        filtered: List[Path] = []
        for entry in entries:
            if entry.is_dir() and entry.name in skip_dir_names:
                continue
            filtered.append(entry)

        shown = 0
        total_entries = len(filtered)
        for entry in filtered:
            if truncated:
                break
            if shown >= per_dir_limit:
                break
            rel = entry.relative_to(root)
            indent = "  " * (depth + 1)
            if entry.is_dir():
                ignored = is_gitignored_cached(entry)
                if ignored:
                    add_line(f"{indent}{rel.as_posix()}/ (gitignored; contents omitted)")
                elif entry.name in skip_contents_dirs:
                    add_line(f"{indent}{rel.as_posix()}/ (contents omitted)")
                elif depth + 1 >= max_depth:
                    add_line(f"{indent}{rel.as_posix()}/ (depth limit)")
                else:
                    add_line(f"{indent}{rel.as_posix()}/")
                    walk(entry, depth + 1)
                shown += 1
            else:
                add_line(f"{indent}{rel.as_posix()}")
                shown += 1

        remaining = total_entries - shown
        if remaining > 0 and not truncated:
            indent = "  " * (depth + 1)
            add_line(f"{indent}... ({remaining} more entries)")

    add_line("./")
    walk(root, 0)
    return "\n".join(lines)


def _write_audit_file(audit_path: Path, root: Path, files: List[Path]) -> None:
    with audit_path.open("w", encoding="utf-8") as fh:
        fh.write(f"# External GPT5-Pro Audit Snapshot\n")
        fh.write(f"Generated at {datetime.now(UTC).isoformat()}\n\n")
        fh.write("## Repository Layout\n")
        fh.write(_render_directory_listing(root))
        fh.write("\n\n")
        fh.write("## File Snapshots\n\n")
        for file_path in files:
            resolved = file_path.as_posix()
            fh.write(f"=== {resolved} ===\n")
            try:
                contents = file_path.read_text(encoding="utf-8", errors="replace")
            except OSError as exc:  # pragma: no cover - filesystem errors
                fh.write(f"[Error reading file: {exc}]\n\n")
                continue
            fh.write(contents)
            if not contents.endswith("\n"):
                fh.write("\n")
            fh.write("\n")


def _auto_commit_and_push(root: Path, audit_path: Path) -> None:
    run(["git", "add", "-A"], cwd=root, check=False)
    status = run(
        ["git", "status", "--porcelain"],
        cwd=root,
        capture_output=True,
        check=False,
    )
    if not (status.stdout or "").strip():
        print("[audit] No changes detected; skipping commit.")
        return
    message = f"chore: external audit snapshot {audit_path.name}"
    commit = run(
        ["git", "commit", "-m", message],
        cwd=root,
        capture_output=True,
        check=False,
    )
    if commit.returncode != 0:
        print(f"[audit] git commit failed: {commit.stderr or commit.stdout}")
        return
    push = run(["git", "push"], cwd=root, capture_output=True, check=False)
    if push.returncode != 0:
        print(f"[audit] git push failed: {push.stderr or push.stdout}")


def create_audit_snapshot(context: RexContext, *, auto_commit: bool = True) -> Path:
    root = context.root
    audit_dir = ensure_dir(root / "for_external_GPT5_pro_audit")
    timestamp = datetime.now(UTC).strftime("%Y%m%d%H%M%S")
    audit_path = audit_dir / f"audit_{timestamp}.md"
    files = _audit_candidate_paths(root)
    if not files:
        print("[audit] No candidate files found for snapshot.")
        return audit_path
    _write_audit_file(audit_path, root, files)
    print(f"[audit] Snapshot written to {audit_path}")
    if auto_commit:
        _auto_commit_and_push(root, audit_path)
    return audit_path

=== /media/skynet3/8tb_a1/rex_codex_agent/scripts/install.sh ===
#!/usr/bin/env bash
# Usage: curl -fsSL https://raw.githubusercontent.com/rexdouglass/rex_codex_agent/main/scripts/install.sh | bash
set -Eeuo pipefail

REPO_SLUG="${REPO_SLUG:-rexdouglass/rex_codex_agent}"
REPO_URL="${REPO_URL:-https://github.com/${REPO_SLUG}.git}"
CHANNEL="${REX_AGENT_CHANNEL:-stable}"   # stable|main|<tag>|<commit>
FORCE="${REX_AGENT_FORCE:-0}"
SKIP_INIT="${REX_AGENT_SKIP_INIT:-0}"
SKIP_DOCTOR="${REX_AGENT_SKIP_DOCTOR:-0}"

usage() {
  cat <<'USAGE'
Usage: ./rex-codex install [--force] [--channel <ref>]
       curl -fsSL https://raw.githubusercontent.com/rexdouglass/rex_codex_agent/main/scripts/install.sh | bash -s -- [options]

Options:
  --force, -f       Remove any existing .rex_agent before reinstalling.
  --channel <ref>   Source ref to install (stable, main, tag, or commit).
  --skip-init       Do not run ./rex-codex init after installation.
  --skip-doctor     Do not run ./rex-codex doctor after installation.
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --force|-f)
      FORCE=1
      ;;
    --channel)
      shift
      CHANNEL="${1:-$CHANNEL}"
      ;;
    --channel=*)
      CHANNEL="${1#*=}"
      ;;
    --skip-init)
      SKIP_INIT=1
      ;;
    --skip-doctor)
      SKIP_DOCTOR=1
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage
      exit 2
      ;;
  esac
  shift || true
done

ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
cd "$ROOT"

AGENT_DIR="$ROOT/.rex_agent"
SRC_DIR="$AGENT_DIR/src"
WRAPPER="$ROOT/rex-codex"

BACKUP_DIR=""
if [[ -d "$AGENT_DIR" && "$FORCE" == "1" ]]; then
  BACKUP_DIR="${AGENT_DIR}.bak.$(date +%s)"
  echo "[*] Removing existing agent (backup at ${BACKUP_DIR})"
  mv "$AGENT_DIR" "$BACKUP_DIR"
fi

mkdir -p "$AGENT_DIR"

cleanup() {
  local status=$?
  if [[ $status -ne 0 ]]; then
    if [[ -n "$BACKUP_DIR" && -d "$BACKUP_DIR" ]]; then
      echo "[!] Install failed; restoring previous agent."
      rm -rf "$AGENT_DIR"
      mv "$BACKUP_DIR" "$AGENT_DIR"
    fi
  else
    if [[ -n "$BACKUP_DIR" && -d "$BACKUP_DIR" ]]; then
      rm -rf "$BACKUP_DIR"
    fi
  fi
}
trap cleanup EXIT

if [[ ! -d "$SRC_DIR/.git" ]]; then
  echo "[*] Cloning ${REPO_SLUG} into .rex_agent/src"
  git clone --depth 1 "$REPO_URL" "$SRC_DIR"
else
  echo "[*] Existing agent found; fetching updates"
  git -C "$SRC_DIR" fetch --all --tags --prune --force
fi

case "$CHANNEL" in
  stable)
    TAG="$(git -C "$SRC_DIR" tag --sort=-v:refname | head -n1)"
    TAG="${TAG:-main}"
    git -C "$SRC_DIR" checkout -q "$TAG"
    ;;
  main) git -C "$SRC_DIR" checkout -q main && git -C "$SRC_DIR" pull --ff-only ;;
  *)    git -C "$SRC_DIR" checkout -q "$CHANNEL" ;;
esac

cat > "$WRAPPER" <<'WRAP'
#!/usr/bin/env bash
set -Eeuo pipefail
ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
REX_HOME="$ROOT/.rex_agent"
REX_SRC="$REX_HOME/src"
export REX_HOME REX_SRC ROOT
if [[ -x "$REX_SRC/bin/rex-codex" ]]; then
  exec bash "$REX_SRC/bin/rex-codex" "$@"
else
  export PYTHONPATH="${REX_SRC}:${PYTHONPATH:-}"
  exec python3 -m rex_codex "$@"
fi
WRAP
chmod +x "$WRAPPER"

echo "[✓] rex_codex_agent installed."

if [[ "$SKIP_INIT" != "1" ]]; then
  echo "[*] Running ./rex-codex init"
  if ! "$WRAPPER" init --no-self-update; then
    echo "[!] ./rex-codex init failed" >&2
    exit 1
  fi
  echo "[✓] ./rex-codex init completed."
else
  echo "[i] Skipped ./rex-codex init (requested)."
fi

if [[ "$SKIP_DOCTOR" != "1" ]]; then
  echo "[*] Running ./rex-codex doctor"
  if ! "$WRAPPER" doctor; then
    echo "[!] ./rex-codex doctor failed" >&2
    exit 1
  fi
  echo "[✓] ./rex-codex doctor completed."
else
  echo "[i] Skipped ./rex-codex doctor (requested)."
fi

echo "Next: ./rex-codex loop    # staged automation loop"

=== /media/skynet3/8tb_a1/rex_codex_agent/scripts/selftest_loop.sh ===
#!/usr/bin/env bash
# Deterministic self-development loop with two feature cards.
set -Eeuo pipefail

this_dir="$(dirname "${BASH_SOURCE[0]}")"
repo_root="$(git -C "$this_dir/.." rev-parse --show-toplevel 2>/dev/null || realpath "$this_dir/..")"
workspace="$repo_root/.selftest_workspace"
log_file="$workspace/selftest.log"
fake_codex="$repo_root/bin/fake-codex"

if [[ ! -x "$fake_codex" ]]; then
  echo "[!] Missing executable Codex stub at $fake_codex" >&2
  exit 1
fi

if [[ -d "$workspace" ]]; then
  rm -rf "$workspace"
fi
mkdir -p "$workspace"
cd "$workspace"
export ROOT="$workspace"
export PYTHONHASHSEED=0

last_status=0

run() {
  printf '\n[%s] %s\n' "$(date -Ins --utc)" "$*" | tee -a "$log_file"
  set +e
  "$@" 2>&1 | tee -a "$log_file"
  status=${PIPESTATUS[0]}
  set -e
  if [[ $status -ne 0 ]]; then
    printf '[!] Command failed (%s) with exit status %s\n' "$*" "$status" | tee -a "$log_file"
    exit "$status"
  fi
  last_status=$status
}

run git init -q
run git config user.email "selftest@rex.codex"
run git config user.name "Rex Codex Selftest"
printf "# selftest workspace\n" > README.md
mkdir -p src/hello
cat > src/hello/__init__.py <<'PY'
from __future__ import annotations

import argparse
from typing import Sequence

DEFAULT_MESSAGE = "Hello World"


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Print a configurable greeting.")
    parser.add_argument("--message", default=DEFAULT_MESSAGE, help="Override the greeting message.")
    parser.add_argument("--repeat", type=int, default=1, help="Number of times to print the greeting.")
    parser.add_argument("--quiet", action="store_true", help="Suppress output.")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    repeats = args.repeat if args.repeat >= 0 else 0
    if not args.quiet and repeats > 0:
        for _ in range(repeats):
            print(args.message)
    return 0


def run() -> int:
    return main(None)
PY
cat > src/hello/__main__.py <<'PY'
from __future__ import annotations

from . import main


def entrypoint() -> int:
    return main(None)


if __name__ == "__main__":
    raise SystemExit(entrypoint())
PY
run git add -A
run git commit -q -m "chore: seed runtime"

export REPO_URL="$repo_root"
export REX_AGENT_CHANNEL=main
export REX_AGENT_FORCE=1
export REX_AGENT_SKIP_DOCTOR=1

run bash "$repo_root/scripts/install.sh" --force --channel main

export CODEX_BIN="$fake_codex"
export REX_AGENT_NO_UPDATE=1

declare -a SLUGS=("hello_greet" "hello_cli")
declare -A TITLES
declare -A SUMMARIES
declare -A ACCEPTANCE

TITLES["hello_greet"]="Print a default greeting"
SUMMARIES["hello_greet"]="Ensure `python -m hello` prints 'Hello World'."
ACCEPTANCE["hello_greet"]="python -m hello outputs Hello World once"

TITLES["hello_cli"]="Configure greeting via CLI"
SUMMARIES["hello_cli"]="Support --message, --repeat, and --quiet flags for the hello app."
ACCEPTANCE["hello_cli"]="python -m hello --message 'Hi' --repeat 2 prints Hi twice"

for slug in "${SLUGS[@]}"; do
  run ./rex-codex card new "$slug" \
    --title "${TITLES[$slug]}" \
    --summary "${SUMMARIES[$slug]}" \
    --acceptance "${ACCEPTANCE[$slug]}"

  run ./rex-codex generator "documents/feature_cards/${slug}.md" --single-pass
  run ./rex-codex discriminator --feature-only --single-pass --disable-llm
done

run ./rex-codex discriminator --global --single-pass --disable-llm
global_status=$last_status

status_output="$(./rex-codex status 2>&1 || true)"
audited_specs="$(find tests/feature_specs -type f -print | sort || true)"

audit_dir="$repo_root/for_external_GPT5_pro_audit"
mkdir -p "$audit_dir"
latest_audit="$(ls -1 "$audit_dir"/audit_*.md 2>/dev/null | sort | tail -1)"
if [[ -z "$latest_audit" ]]; then
  latest_audit="$audit_dir/audit_$(date -u +%Y%m%d%H%M%S)_selftest.md"
  touch "$latest_audit"
fi

{
  printf '\n## Local Selftest Loop (%s UTC)\n\n' "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  printf '- Workspace: %s\n' "$workspace"
  printf '- Features exercised: %s\n' "${SLUGS[*]}"
  printf '- Global discriminator exit code: %s\n\n' "$global_status"
  printf '### rex-codex status\n\n```\n%s\n```\n' "$status_output"
  printf '### Generated spec files\n\n```\n%s\n```\n' "$audited_specs"
  printf '### Command log\n\n```\n'
  cat "$log_file"
  printf '```\n'
  printf '### Runtime module (src/hello/__init__.py)\n\n```python\n'
  cat src/hello/__init__.py
  printf '```\n'
  printf '### CLI entry (src/hello/__main__.py)\n\n```python\n'
  cat src/hello/__main__.py
  printf '```\n'
} >>"$latest_audit"

cd "$repo_root"

if [[ "${SELFTEST_KEEP:-0}" == "1" ]]; then
  echo "[i] Preserved workspace at $workspace"
else
  rm -rf "$workspace"
  echo "[*] Removed workspace at $workspace"
fi

=== /media/skynet3/8tb_a1/rex_codex_agent/scripts/smoke_e2e.sh ===
#!/usr/bin/env bash
# Deterministic end-to-end smoke of rex_codex_agent using the local checkout and Codex stub.
set -Eeuo pipefail

this_dir="$(dirname "${BASH_SOURCE[0]}")"
repo_root="$(git -C "$this_dir/.." rev-parse --show-toplevel 2>/dev/null || realpath "$this_dir/..")"
fake_codex="$repo_root/bin/fake-codex"

if [[ ! -x "$fake_codex" ]]; then
  echo "[!] Missing executable Codex stub at $fake_codex" >&2
  exit 1
fi

workdir="$(mktemp -d -t rex-codex-smoke.XXXXXX)"
keep="${KEEP:-0}"
cleanup() {
  status=$?
  if [[ "$keep" == "1" ]]; then
    echo "[i] Kept workdir: $workdir"
  else
    rm -rf "$workdir"
  fi
  exit $status
}
trap cleanup EXIT

echo "[*] Workdir: $workdir"
cd "$workdir"

mkdir dummy && cd dummy
git init -q
git config user.email "smoke@test.local"
git config user.name "Rex Codex Smoke"
printf "# dummy project\n" > README.md
mkdir -p src/hello
cat > src/hello/__init__.py <<'PY'
from __future__ import annotations

import argparse
from typing import Sequence

DEFAULT_MESSAGE = "Hello World"


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Print a configurable greeting.")
    parser.add_argument("--message", default=DEFAULT_MESSAGE, help="Override the greeting message.")
    parser.add_argument("--repeat", type=int, default=1, help="Number of times to print the greeting.")
    parser.add_argument("--quiet", action="store_true", help="Suppress output.")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    repeats = args.repeat if args.repeat >= 0 else 0
    if not args.quiet and repeats > 0:
        for _ in range(repeats):
            print(args.message)
    return 0


def run() -> int:
    return main(None)
PY
cat > src/hello/__main__.py <<'PY'
from __future__ import annotations

from . import main


def entrypoint() -> int:
    return main(None)


if __name__ == "__main__":
    raise SystemExit(entrypoint())
PY
git add -A
git commit -m "chore: seed dummy runtime" >/dev/null

export REPO_URL="$repo_root"
export REX_AGENT_CHANNEL=main
export REX_AGENT_FORCE=1
export REX_AGENT_SKIP_DOCTOR=1

bash "$repo_root/scripts/install.sh" --force --channel main

declare -a SLUGS=("hello_greet" "hello_cli")
declare -A TITLES
declare -A SUMMARIES
declare -A ACCEPTANCE

TITLES["hello_greet"]="Print a default greeting"
SUMMARIES["hello_greet"]="Ensure `python -m hello` prints 'Hello World'."
ACCEPTANCE["hello_greet"]="python -m hello outputs Hello World once"

TITLES["hello_cli"]="Configure greeting via CLI"
SUMMARIES["hello_cli"]="Support --message, --repeat, and --quiet flags for the hello app."
ACCEPTANCE["hello_cli"]="python -m hello --message 'Hi' --repeat 2 prints Hi twice"

for slug in "${SLUGS[@]}"; do
  ./rex-codex card new "$slug" \
    --title "${TITLES[$slug]}" \
    --summary "${SUMMARIES[$slug]}" \
    --acceptance "${ACCEPTANCE[$slug]}"
done

export CODEX_BIN="$fake_codex"
export REX_AGENT_NO_UPDATE=1

./rex-codex loop --feature-only --no-self-update --tail 120
./rex-codex discriminator --global --single-pass --disable-llm

echo
echo "[✓] Smoke run complete."
echo "    Created spec files:"
find tests/feature_specs -maxdepth 3 -type f -print || true
echo
./rex-codex status


## Local Selftest Loop (2025-10-16T05:21:28Z UTC)

### rex-codex status

```
Active Feature:
  slug: readme
  card: documents/feature_cards/README.md
  updated_at: unknown
Configured Stages:
  - sanity
  - deps
  - specs
  - unit
  - style
LLM Settings:
  bin: npx --yes @openai/codex
  flags: --yolo
  model: 
```
### Command log

```

[2025-10-16T05:21:21,323106483+00:00] git init -q

[2025-10-16T05:21:21,331094966+00:00] git config user.email selftest@rex.codex

[2025-10-16T05:21:21,337309024+00:00] git config user.name Rex Codex Selftest

[2025-10-16T05:21:21,346258873+00:00] git add -A

[2025-10-16T05:21:21,352226147+00:00] git commit -q -m chore: seed runtime

[2025-10-16T05:21:21,360245989+00:00] bash /media/skynet3/8tb_a1/rex_codex_agent/scripts/install.sh --force --channel main
[*] Cloning rexdouglass/rex_codex_agent into .rex_agent/src
Cloning into '/media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src'...
warning: --depth is ignored in local clones; use file:// instead.
done.
Already up to date.
[✓] rex_codex_agent installed.
[*] Running ./rex-codex init
Requirement already satisfied: pip in ./.venv/lib/python3.13/site-packages (25.2)
Collecting pytest==8.0.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached pytest-8.0.2-py3-none-any.whl.metadata (7.7 kB)
Collecting pytest-xdist==3.5.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 2))
  Using cached pytest_xdist-3.5.0-py3-none-any.whl.metadata (3.1 kB)
Collecting pytest-cov==4.1.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 3))
  Using cached pytest_cov-4.1.0-py3-none-any.whl.metadata (26 kB)
Collecting black==24.4.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached black-24.4.2-py3-none-any.whl.metadata (77 kB)
Collecting isort==5.13.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 5))
  Using cached isort-5.13.2-py3-none-any.whl.metadata (12 kB)
Collecting ruff==0.3.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 6))
  Using cached ruff-0.3.2-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (23 kB)
Collecting flake8==7.0.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached flake8-7.0.0-py2.py3-none-any.whl.metadata (3.8 kB)
Collecting mypy==1.8.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 8))
  Using cached mypy-1.8.0-py3-none-any.whl.metadata (1.8 kB)
Collecting iniconfig (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached iniconfig-2.1.0-py3-none-any.whl.metadata (2.7 kB)
Collecting packaging (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached packaging-25.0-py3-none-any.whl.metadata (3.3 kB)
Collecting pluggy<2.0,>=1.3.0 (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached pluggy-1.6.0-py3-none-any.whl.metadata (4.8 kB)
Collecting execnet>=1.1 (from pytest-xdist==3.5.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 2))
  Using cached execnet-2.1.1-py3-none-any.whl.metadata (2.9 kB)
Collecting coverage>=5.2.1 (from coverage[toml]>=5.2.1->pytest-cov==4.1.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 3))
  Using cached coverage-7.11.0-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl.metadata (9.0 kB)
Collecting click>=8.0.0 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached click-8.3.0-py3-none-any.whl.metadata (2.6 kB)
Collecting mypy-extensions>=0.4.3 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached mypy_extensions-1.1.0-py3-none-any.whl.metadata (1.1 kB)
Collecting pathspec>=0.9.0 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached pathspec-0.12.1-py3-none-any.whl.metadata (21 kB)
Collecting platformdirs>=2 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached platformdirs-4.5.0-py3-none-any.whl.metadata (12 kB)
Collecting mccabe<0.8.0,>=0.7.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached mccabe-0.7.0-py2.py3-none-any.whl.metadata (5.0 kB)
Collecting pycodestyle<2.12.0,>=2.11.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached pycodestyle-2.11.1-py2.py3-none-any.whl.metadata (4.5 kB)
Collecting pyflakes<3.3.0,>=3.2.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached pyflakes-3.2.0-py2.py3-none-any.whl.metadata (3.5 kB)
Collecting typing-extensions>=4.1.0 (from mypy==1.8.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 8))
  Using cached typing_extensions-4.15.0-py3-none-any.whl.metadata (3.3 kB)
Using cached pytest-8.0.2-py3-none-any.whl (333 kB)
Using cached pytest_xdist-3.5.0-py3-none-any.whl (42 kB)
Using cached pytest_cov-4.1.0-py3-none-any.whl (21 kB)
Using cached black-24.4.2-py3-none-any.whl (205 kB)
Using cached isort-5.13.2-py3-none-any.whl (92 kB)
Using cached ruff-0.3.2-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (7.9 MB)
Using cached flake8-7.0.0-py2.py3-none-any.whl (57 kB)
Using cached mypy-1.8.0-py3-none-any.whl (2.6 MB)
Using cached mccabe-0.7.0-py2.py3-none-any.whl (7.3 kB)
Using cached pluggy-1.6.0-py3-none-any.whl (20 kB)
Using cached pycodestyle-2.11.1-py2.py3-none-any.whl (31 kB)
Using cached pyflakes-3.2.0-py2.py3-none-any.whl (62 kB)
Using cached click-8.3.0-py3-none-any.whl (107 kB)
Using cached coverage-7.11.0-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl (249 kB)
Using cached execnet-2.1.1-py3-none-any.whl (40 kB)
Using cached mypy_extensions-1.1.0-py3-none-any.whl (5.0 kB)
Using cached packaging-25.0-py3-none-any.whl (66 kB)
Using cached pathspec-0.12.1-py3-none-any.whl (31 kB)
Using cached platformdirs-4.5.0-py3-none-any.whl (18 kB)
Using cached typing_extensions-4.15.0-py3-none-any.whl (44 kB)
Using cached iniconfig-2.1.0-py3-none-any.whl (6.0 kB)
Installing collected packages: typing-extensions, ruff, pyflakes, pycodestyle, pluggy, platformdirs, pathspec, packaging, mypy-extensions, mccabe, isort, iniconfig, execnet, coverage, click, pytest, mypy, flake8, black, pytest-xdist, pytest-cov

Successfully installed black-24.4.2 click-8.3.0 coverage-7.11.0 execnet-2.1.1 flake8-7.0.0 iniconfig-2.1.0 isort-5.13.2 mccabe-0.7.0 mypy-1.8.0 mypy-extensions-1.1.0 packaging-25.0 pathspec-0.12.1 platformdirs-4.5.0 pluggy-1.6.0 pycodestyle-2.11.1 pyflakes-3.2.0 pytest-8.0.2 pytest-cov-4.1.0 pytest-xdist-3.5.0 ruff-0.3.2 typing-extensions-4.15.0
[*] Bootstrapping Python environment…
[*] Creating Python virtual environment (.venv)…
[✓] Project initialized. Try: ./rex-codex loop
[✓] ./rex-codex init completed.
[i] Skipped ./rex-codex doctor (requested).
Next: ./rex-codex loop    # staged automation loop
```
### Runtime module (src/hello/__init__.py)

```python
from __future__ import annotations

import argparse
from typing import Sequence

DEFAULT_MESSAGE = "Hello World"


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Print a configurable greeting.")
    parser.add_argument("--message", default=DEFAULT_MESSAGE, help="Override the greeting message.")
    parser.add_argument("--repeat", type=int, default=1, help="Number of times to print the greeting.")
    parser.add_argument("--quiet", action="store_true", help="Suppress output.")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    repeats = args.repeat if args.repeat >= 0 else 0
    if not args.quiet and repeats > 0:
        for _ in range(repeats):
            print(args.message)
    return 0


def run() -> int:
    return main(None)
```
### CLI entry (src/hello/__main__.py)

```python
from __future__ import annotations

from . import main


def entrypoint() -> int:
    return main(None)


if __name__ == "__main__":
    raise SystemExit(entrypoint())
```

## Local Selftest Loop (2025-10-16T05:21:55Z UTC)

- Workspace: /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace
- Features exercised: hello_greet hello_cli
- Last command exit code: 0
- Script exit code: 1

### rex-codex status

```
Active Feature:
  slug: readme
  card: documents/feature_cards/README.md
  updated_at: unknown
Configured Stages:
  - sanity
  - deps
  - specs
  - unit
  - style
LLM Settings:
  bin: npx --yes @openai/codex
  flags: --yolo
  model: 
```
### Command log

```

[2025-10-16T05:21:48,012302368+00:00] git init -q

[2025-10-16T05:21:48,019312591+00:00] git config user.email selftest@rex.codex

[2025-10-16T05:21:48,025858020+00:00] git config user.name Rex Codex Selftest

[2025-10-16T05:21:48,036220071+00:00] git add -A

[2025-10-16T05:21:48,043106621+00:00] git commit -q -m chore: seed runtime

[2025-10-16T05:21:48,053994190+00:00] bash /media/skynet3/8tb_a1/rex_codex_agent/scripts/install.sh --force --channel main
[*] Cloning rexdouglass/rex_codex_agent into .rex_agent/src
Cloning into '/media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src'...
warning: --depth is ignored in local clones; use file:// instead.
done.
Already up to date.
[✓] rex_codex_agent installed.
[*] Running ./rex-codex init
Requirement already satisfied: pip in ./.venv/lib/python3.13/site-packages (25.2)
Collecting pytest==8.0.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached pytest-8.0.2-py3-none-any.whl.metadata (7.7 kB)
Collecting pytest-xdist==3.5.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 2))
  Using cached pytest_xdist-3.5.0-py3-none-any.whl.metadata (3.1 kB)
Collecting pytest-cov==4.1.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 3))
  Using cached pytest_cov-4.1.0-py3-none-any.whl.metadata (26 kB)
Collecting black==24.4.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached black-24.4.2-py3-none-any.whl.metadata (77 kB)
Collecting isort==5.13.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 5))
  Using cached isort-5.13.2-py3-none-any.whl.metadata (12 kB)
Collecting ruff==0.3.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 6))
  Using cached ruff-0.3.2-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (23 kB)
Collecting flake8==7.0.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached flake8-7.0.0-py2.py3-none-any.whl.metadata (3.8 kB)
Collecting mypy==1.8.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 8))
  Using cached mypy-1.8.0-py3-none-any.whl.metadata (1.8 kB)
Collecting iniconfig (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached iniconfig-2.1.0-py3-none-any.whl.metadata (2.7 kB)
Collecting packaging (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached packaging-25.0-py3-none-any.whl.metadata (3.3 kB)
Collecting pluggy<2.0,>=1.3.0 (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached pluggy-1.6.0-py3-none-any.whl.metadata (4.8 kB)
Collecting execnet>=1.1 (from pytest-xdist==3.5.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 2))
  Using cached execnet-2.1.1-py3-none-any.whl.metadata (2.9 kB)
Collecting coverage>=5.2.1 (from coverage[toml]>=5.2.1->pytest-cov==4.1.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 3))
  Using cached coverage-7.11.0-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl.metadata (9.0 kB)
Collecting click>=8.0.0 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached click-8.3.0-py3-none-any.whl.metadata (2.6 kB)
Collecting mypy-extensions>=0.4.3 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached mypy_extensions-1.1.0-py3-none-any.whl.metadata (1.1 kB)
Collecting pathspec>=0.9.0 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached pathspec-0.12.1-py3-none-any.whl.metadata (21 kB)
Collecting platformdirs>=2 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached platformdirs-4.5.0-py3-none-any.whl.metadata (12 kB)
Collecting mccabe<0.8.0,>=0.7.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached mccabe-0.7.0-py2.py3-none-any.whl.metadata (5.0 kB)
Collecting pycodestyle<2.12.0,>=2.11.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached pycodestyle-2.11.1-py2.py3-none-any.whl.metadata (4.5 kB)
Collecting pyflakes<3.3.0,>=3.2.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached pyflakes-3.2.0-py2.py3-none-any.whl.metadata (3.5 kB)
Collecting typing-extensions>=4.1.0 (from mypy==1.8.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 8))
  Using cached typing_extensions-4.15.0-py3-none-any.whl.metadata (3.3 kB)
Using cached pytest-8.0.2-py3-none-any.whl (333 kB)
Using cached pytest_xdist-3.5.0-py3-none-any.whl (42 kB)
Using cached pytest_cov-4.1.0-py3-none-any.whl (21 kB)
Using cached black-24.4.2-py3-none-any.whl (205 kB)
Using cached isort-5.13.2-py3-none-any.whl (92 kB)
Using cached ruff-0.3.2-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (7.9 MB)
Using cached flake8-7.0.0-py2.py3-none-any.whl (57 kB)
Using cached mypy-1.8.0-py3-none-any.whl (2.6 MB)
Using cached mccabe-0.7.0-py2.py3-none-any.whl (7.3 kB)
Using cached pluggy-1.6.0-py3-none-any.whl (20 kB)
Using cached pycodestyle-2.11.1-py2.py3-none-any.whl (31 kB)
Using cached pyflakes-3.2.0-py2.py3-none-any.whl (62 kB)
Using cached click-8.3.0-py3-none-any.whl (107 kB)
Using cached coverage-7.11.0-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl (249 kB)
Using cached execnet-2.1.1-py3-none-any.whl (40 kB)
Using cached mypy_extensions-1.1.0-py3-none-any.whl (5.0 kB)
Using cached packaging-25.0-py3-none-any.whl (66 kB)
Using cached pathspec-0.12.1-py3-none-any.whl (31 kB)
Using cached platformdirs-4.5.0-py3-none-any.whl (18 kB)
Using cached typing_extensions-4.15.0-py3-none-any.whl (44 kB)
Using cached iniconfig-2.1.0-py3-none-any.whl (6.0 kB)
Installing collected packages: typing-extensions, ruff, pyflakes, pycodestyle, pluggy, platformdirs, pathspec, packaging, mypy-extensions, mccabe, isort, iniconfig, execnet, coverage, click, pytest, mypy, flake8, black, pytest-xdist, pytest-cov

Successfully installed black-24.4.2 click-8.3.0 coverage-7.11.0 execnet-2.1.1 flake8-7.0.0 iniconfig-2.1.0 isort-5.13.2 mccabe-0.7.0 mypy-1.8.0 mypy-extensions-1.1.0 packaging-25.0 pathspec-0.12.1 platformdirs-4.5.0 pluggy-1.6.0 pycodestyle-2.11.1 pyflakes-3.2.0 pytest-8.0.2 pytest-cov-4.1.0 pytest-xdist-3.5.0 ruff-0.3.2 typing-extensions-4.15.0
[*] Bootstrapping Python environment…
[*] Creating Python virtual environment (.venv)…
[✓] Project initialized. Try: ./rex-codex loop
[✓] ./rex-codex init completed.
[i] Skipped ./rex-codex doctor (requested).
Next: ./rex-codex loop    # staged automation loop
```
### Runtime module (src/hello/__init__.py)

```python
from __future__ import annotations

import argparse
from typing import Sequence

DEFAULT_MESSAGE = "Hello World"


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Print a configurable greeting.")
    parser.add_argument("--message", default=DEFAULT_MESSAGE, help="Override the greeting message.")
    parser.add_argument("--repeat", type=int, default=1, help="Number of times to print the greeting.")
    parser.add_argument("--quiet", action="store_true", help="Suppress output.")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    repeats = args.repeat if args.repeat >= 0 else 0
    if not args.quiet and repeats > 0:
        for _ in range(repeats):
            print(args.message)
    return 0


def run() -> int:
    return main(None)
```
### CLI entry (src/hello/__main__.py)

```python
from __future__ import annotations

from . import main


def entrypoint() -> int:
    return main(None)


if __name__ == "__main__":
    raise SystemExit(entrypoint())
```

## Local Selftest Loop (2025-10-16T05:23:42Z UTC)

- Workspace: /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace
- Features exercised: hello_greet hello_cli
- Last command exit code: 0
- Script exit code: 1

### rex-codex status

```
Active Feature:
  slug: readme
  card: documents/feature_cards/README.md
  updated_at: unknown
Configured Stages:
  - sanity
  - deps
  - specs
  - unit
  - style
LLM Settings:
  bin: npx --yes @openai/codex
  flags: --yolo
  model: 
```
### Command log

```

[2025-10-16T05:23:35,749199308+00:00] git init -q

[2025-10-16T05:23:35,757961456+00:00] git config user.email selftest@rex.codex

[2025-10-16T05:23:35,763409679+00:00] git config user.name Rex Codex Selftest

[2025-10-16T05:23:35,773776361+00:00] git add -A

[2025-10-16T05:23:35,779895535+00:00] git commit -q -m chore: seed runtime

[2025-10-16T05:23:35,788728657+00:00] bash /media/skynet3/8tb_a1/rex_codex_agent/scripts/install.sh --force --channel main
[*] Cloning rexdouglass/rex_codex_agent into .rex_agent/src
Cloning into '/media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src'...
warning: --depth is ignored in local clones; use file:// instead.
done.
Already up to date.
[✓] rex_codex_agent installed.
[*] Running ./rex-codex init
Requirement already satisfied: pip in ./.venv/lib/python3.13/site-packages (25.2)
Collecting pytest==8.0.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached pytest-8.0.2-py3-none-any.whl.metadata (7.7 kB)
Collecting pytest-xdist==3.5.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 2))
  Using cached pytest_xdist-3.5.0-py3-none-any.whl.metadata (3.1 kB)
Collecting pytest-cov==4.1.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 3))
  Using cached pytest_cov-4.1.0-py3-none-any.whl.metadata (26 kB)
Collecting black==24.4.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached black-24.4.2-py3-none-any.whl.metadata (77 kB)
Collecting isort==5.13.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 5))
  Using cached isort-5.13.2-py3-none-any.whl.metadata (12 kB)
Collecting ruff==0.3.2 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 6))
  Using cached ruff-0.3.2-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (23 kB)
Collecting flake8==7.0.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached flake8-7.0.0-py2.py3-none-any.whl.metadata (3.8 kB)
Collecting mypy==1.8.0 (from -r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 8))
  Using cached mypy-1.8.0-py3-none-any.whl.metadata (1.8 kB)
Collecting iniconfig (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached iniconfig-2.1.0-py3-none-any.whl.metadata (2.7 kB)
Collecting packaging (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached packaging-25.0-py3-none-any.whl.metadata (3.3 kB)
Collecting pluggy<2.0,>=1.3.0 (from pytest==8.0.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 1))
  Using cached pluggy-1.6.0-py3-none-any.whl.metadata (4.8 kB)
Collecting execnet>=1.1 (from pytest-xdist==3.5.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 2))
  Using cached execnet-2.1.1-py3-none-any.whl.metadata (2.9 kB)
Collecting coverage>=5.2.1 (from coverage[toml]>=5.2.1->pytest-cov==4.1.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 3))
  Using cached coverage-7.11.0-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl.metadata (9.0 kB)
Collecting click>=8.0.0 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached click-8.3.0-py3-none-any.whl.metadata (2.6 kB)
Collecting mypy-extensions>=0.4.3 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached mypy_extensions-1.1.0-py3-none-any.whl.metadata (1.1 kB)
Collecting pathspec>=0.9.0 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached pathspec-0.12.1-py3-none-any.whl.metadata (21 kB)
Collecting platformdirs>=2 (from black==24.4.2->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 4))
  Using cached platformdirs-4.5.0-py3-none-any.whl.metadata (12 kB)
Collecting mccabe<0.8.0,>=0.7.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached mccabe-0.7.0-py2.py3-none-any.whl.metadata (5.0 kB)
Collecting pycodestyle<2.12.0,>=2.11.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached pycodestyle-2.11.1-py2.py3-none-any.whl.metadata (4.5 kB)
Collecting pyflakes<3.3.0,>=3.2.0 (from flake8==7.0.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 7))
  Using cached pyflakes-3.2.0-py2.py3-none-any.whl.metadata (3.5 kB)
Collecting typing-extensions>=4.1.0 (from mypy==1.8.0->-r /media/skynet3/8tb_a1/rex_codex_agent/.selftest_workspace/.rex_agent/src/templates/requirements-dev.txt (line 8))
  Using cached typing_extensions-4.15.0-py3-none-any.whl.metadata (3.3 kB)
Using cached pytest-8.0.2-py3-none-any.whl (333 kB)
Using cached pytest_xdist-3.5.0-py3-none-any.whl (42 kB)
Using cached pytest_cov-4.1.0-py3-none-any.whl (21 kB)
Using cached black-24.4.2-py3-none-any.whl (205 kB)
Using cached isort-5.13.2-py3-none-any.whl (92 kB)
Using cached ruff-0.3.2-py3-none-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (7.9 MB)
Using cached flake8-7.0.0-py2.py3-none-any.whl (57 kB)
Using cached mypy-1.8.0-py3-none-any.whl (2.6 MB)
Using cached mccabe-0.7.0-py2.py3-none-any.whl (7.3 kB)
Using cached pluggy-1.6.0-py3-none-any.whl (20 kB)
Using cached pycodestyle-2.11.1-py2.py3-none-any.whl (31 kB)
Using cached pyflakes-3.2.0-py2.py3-none-any.whl (62 kB)
Using cached click-8.3.0-py3-none-any.whl (107 kB)
Using cached coverage-7.11.0-cp313-cp313-manylinux1_x86_64.manylinux_2_28_x86_64.manylinux_2_5_x86_64.whl (249 kB)
Using cached execnet-2.1.1-py3-none-any.whl (40 kB)
Using cached mypy_extensions-1.1.0-py3-none-any.whl (5.0 kB)
Using cached packaging-25.0-py3-none-any.whl (66 kB)
Using cached pathspec-0.12.1-py3-none-any.whl (31 kB)
Using cached platformdirs-4.5.0-py3-none-any.whl (18 kB)
Using cached typing_extensions-4.15.0-py3-none-any.whl (44 kB)
Using cached iniconfig-2.1.0-py3-none-any.whl (6.0 kB)
Installing collected packages: typing-extensions, ruff, pyflakes, pycodestyle, pluggy, platformdirs, pathspec, packaging, mypy-extensions, mccabe, isort, iniconfig, execnet, coverage, click, pytest, mypy, flake8, black, pytest-xdist, pytest-cov

Successfully installed black-24.4.2 click-8.3.0 coverage-7.11.0 execnet-2.1.1 flake8-7.0.0 iniconfig-2.1.0 isort-5.13.2 mccabe-0.7.0 mypy-1.8.0 mypy-extensions-1.1.0 packaging-25.0 pathspec-0.12.1 platformdirs-4.5.0 pluggy-1.6.0 pycodestyle-2.11.1 pyflakes-3.2.0 pytest-8.0.2 pytest-cov-4.1.0 pytest-xdist-3.5.0 ruff-0.3.2 typing-extensions-4.15.0
[*] Bootstrapping Python environment…
[*] Creating Python virtual environment (.venv)…
[✓] Project initialized. Try: ./rex-codex loop
[✓] ./rex-codex init completed.
[i] Skipped ./rex-codex doctor (requested).
Next: ./rex-codex loop    # staged automation loop
```
### Runtime module (src/hello/__init__.py)

```python
from __future__ import annotations

import argparse
from typing import Sequence

DEFAULT_MESSAGE = "Hello World"


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Print a configurable greeting.")
    parser.add_argument("--message", default=DEFAULT_MESSAGE, help="Override the greeting message.")
    parser.add_argument("--repeat", type=int, default=1, help="Number of times to print the greeting.")
    parser.add_argument("--quiet", action="store_true", help="Suppress output.")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    repeats = args.repeat if args.repeat >= 0 else 0
    if not args.quiet and repeats > 0:
        for _ in range(repeats):
            print(args.message)
    return 0


def run() -> int:
    return main(None)
```
### CLI entry (src/hello/__main__.py)

```python
from __future__ import annotations

from . import main


def entrypoint() -> int:
    return main(None)


if __name__ == "__main__":
    raise SystemExit(entrypoint())
```
